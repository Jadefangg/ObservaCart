{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as api from '@opentelemetry/api';\nimport { SemconvStability, semconvStabilityFromStr, isWrapped, InstrumentationBase, safeExecuteInTheMiddle } from '@opentelemetry/instrumentation';\nimport * as core from '@opentelemetry/core';\nimport * as web from '@opentelemetry/sdk-trace-web';\nimport { AttributeNames } from './enums/AttributeNames';\nimport { ATTR_HTTP_STATUS_CODE, ATTR_HTTP_HOST, ATTR_HTTP_USER_AGENT, ATTR_HTTP_SCHEME, ATTR_HTTP_URL, ATTR_HTTP_METHOD, ATTR_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED, ATTR_HTTP_REQUEST_BODY_SIZE } from '../src/semconv';\nimport { ATTR_ERROR_TYPE, ATTR_HTTP_REQUEST_METHOD, ATTR_HTTP_REQUEST_METHOD_ORIGINAL, ATTR_HTTP_RESPONSE_STATUS_CODE, ATTR_SERVER_ADDRESS, ATTR_SERVER_PORT, ATTR_URL_FULL } from '@opentelemetry/semantic-conventions';\nimport { getFetchBodyLength, normalizeHttpRequestMethod, serverPortFromUrl } from './utils';\nimport { VERSION } from './version';\nimport { _globalThis } from '@opentelemetry/core';\n// how long to wait for observer to collect information about resources\n// this is needed as event \"load\" is called before observer\n// hard to say how long it should really wait, seems like 300ms is\n// safe enough\nconst OBSERVER_WAIT_TIME_MS = 300;\nconst isNode = typeof process === 'object' && process.release?.name === 'node';\n/**\n * This class represents a fetch plugin for auto instrumentation\n */\nexport class FetchInstrumentation extends InstrumentationBase {\n  component = 'fetch';\n  version = VERSION;\n  moduleName = this.component;\n  _usedResources = new WeakSet();\n  _tasksCount = 0;\n  _semconvStability;\n  constructor(config = {}) {\n    super('@opentelemetry/instrumentation-fetch', VERSION, config);\n    this._semconvStability = semconvStabilityFromStr('http', config?.semconvStabilityOptIn);\n  }\n  init() {}\n  /**\n   * Add cors pre flight child span\n   * @param span\n   * @param corsPreFlightRequest\n   */\n  _addChildSpan(span, corsPreFlightRequest) {\n    const childSpan = this.tracer.startSpan('CORS Preflight', {\n      startTime: corsPreFlightRequest[web.PerformanceTimingNames.FETCH_START]\n    }, api.trace.setSpan(api.context.active(), span));\n    const skipOldSemconvContentLengthAttrs = !(this._semconvStability & SemconvStability.OLD);\n    web.addSpanNetworkEvents(childSpan, corsPreFlightRequest, this.getConfig().ignoreNetworkEvents, undefined, skipOldSemconvContentLengthAttrs);\n    childSpan.end(corsPreFlightRequest[web.PerformanceTimingNames.RESPONSE_END]);\n  }\n  /**\n   * Adds more attributes to span just before ending it\n   * @param span\n   * @param response\n   */\n  _addFinalSpanAttributes(span, response) {\n    const parsedUrl = web.parseUrl(response.url);\n    if (this._semconvStability & SemconvStability.OLD) {\n      span.setAttribute(ATTR_HTTP_STATUS_CODE, response.status);\n      if (response.statusText != null) {\n        span.setAttribute(AttributeNames.HTTP_STATUS_TEXT, response.statusText);\n      }\n      span.setAttribute(ATTR_HTTP_HOST, parsedUrl.host);\n      span.setAttribute(ATTR_HTTP_SCHEME, parsedUrl.protocol.replace(':', ''));\n      if (typeof navigator !== 'undefined') {\n        span.setAttribute(ATTR_HTTP_USER_AGENT, navigator.userAgent);\n      }\n    }\n    if (this._semconvStability & SemconvStability.STABLE) {\n      span.setAttribute(ATTR_HTTP_RESPONSE_STATUS_CODE, response.status);\n      // TODO: Set server.{address,port} at span creation for sampling decisions\n      // (a \"SHOULD\" requirement in semconv).\n      span.setAttribute(ATTR_SERVER_ADDRESS, parsedUrl.hostname);\n      const serverPort = serverPortFromUrl(parsedUrl);\n      if (serverPort) {\n        span.setAttribute(ATTR_SERVER_PORT, serverPort);\n      }\n    }\n  }\n  /**\n   * Add headers\n   * @param options\n   * @param spanUrl\n   */\n  _addHeaders(options, spanUrl) {\n    if (!web.shouldPropagateTraceHeaders(spanUrl, this.getConfig().propagateTraceHeaderCorsUrls)) {\n      const headers = {};\n      api.propagation.inject(api.context.active(), headers);\n      if (Object.keys(headers).length > 0) {\n        this._diag.debug('headers inject skipped due to CORS policy');\n      }\n      return;\n    }\n    if (options instanceof Request) {\n      api.propagation.inject(api.context.active(), options.headers, {\n        set: (h, k, v) => h.set(k, typeof v === 'string' ? v : String(v))\n      });\n    } else if (options.headers instanceof Headers) {\n      api.propagation.inject(api.context.active(), options.headers, {\n        set: (h, k, v) => h.set(k, typeof v === 'string' ? v : String(v))\n      });\n    } else if (options.headers instanceof Map) {\n      api.propagation.inject(api.context.active(), options.headers, {\n        set: (h, k, v) => h.set(k, typeof v === 'string' ? v : String(v))\n      });\n    } else {\n      const headers = {};\n      api.propagation.inject(api.context.active(), headers);\n      options.headers = Object.assign({}, headers, options.headers || {});\n    }\n  }\n  /**\n   * Clears the resource timings and all resources assigned with spans\n   *     when {@link FetchPluginConfig.clearTimingResources} is\n   *     set to true (default false)\n   * @private\n   */\n  _clearResources() {\n    if (this._tasksCount === 0 && this.getConfig().clearTimingResources) {\n      performance.clearResourceTimings();\n      this._usedResources = new WeakSet();\n    }\n  }\n  /**\n   * Creates a new span\n   * @param url\n   * @param options\n   */\n  _createSpan(url, options = {}) {\n    if (core.isUrlIgnored(url, this.getConfig().ignoreUrls)) {\n      this._diag.debug('ignoring span as url matches ignored url');\n      return;\n    }\n    let name = '';\n    const attributes = {};\n    if (this._semconvStability & SemconvStability.OLD) {\n      const method = (options.method || 'GET').toUpperCase();\n      name = `HTTP ${method}`;\n      attributes[AttributeNames.COMPONENT] = this.moduleName;\n      attributes[ATTR_HTTP_METHOD] = method;\n      attributes[ATTR_HTTP_URL] = url;\n    }\n    if (this._semconvStability & SemconvStability.STABLE) {\n      const origMethod = options.method;\n      const normMethod = normalizeHttpRequestMethod(options.method || 'GET');\n      if (!name) {\n        // The \"old\" span name wins if emitting both old and stable semconv\n        // ('http/dup').\n        name = normMethod;\n      }\n      attributes[ATTR_HTTP_REQUEST_METHOD] = normMethod;\n      if (normMethod !== origMethod) {\n        attributes[ATTR_HTTP_REQUEST_METHOD_ORIGINAL] = origMethod;\n      }\n      attributes[ATTR_URL_FULL] = url;\n    }\n    return this.tracer.startSpan(name, {\n      kind: api.SpanKind.CLIENT,\n      attributes\n    });\n  }\n  /**\n   * Finds appropriate resource and add network events to the span\n   * @param span\n   * @param resourcesObserver\n   * @param endTime\n   */\n  _findResourceAndAddNetworkEvents(span, resourcesObserver, endTime) {\n    let resources = resourcesObserver.entries;\n    if (!resources.length) {\n      if (!performance.getEntriesByType) {\n        return;\n      }\n      // fallback - either Observer is not available or it took longer\n      // then OBSERVER_WAIT_TIME_MS and observer didn't collect enough\n      // information\n      resources = performance.getEntriesByType('resource');\n    }\n    const resource = web.getResource(resourcesObserver.spanUrl, resourcesObserver.startTime, endTime, resources, this._usedResources, 'fetch');\n    if (resource.mainRequest) {\n      const mainRequest = resource.mainRequest;\n      this._markResourceAsUsed(mainRequest);\n      const corsPreFlightRequest = resource.corsPreFlightRequest;\n      if (corsPreFlightRequest) {\n        this._addChildSpan(span, corsPreFlightRequest);\n        this._markResourceAsUsed(corsPreFlightRequest);\n      }\n      const skipOldSemconvContentLengthAttrs = !(this._semconvStability & SemconvStability.OLD);\n      web.addSpanNetworkEvents(span, mainRequest, this.getConfig().ignoreNetworkEvents, undefined, skipOldSemconvContentLengthAttrs);\n    }\n  }\n  /**\n   * Marks certain [resource]{@link PerformanceResourceTiming} when information\n   * from this is used to add events to span.\n   * This is done to avoid reusing the same resource again for next span\n   * @param resource\n   */\n  _markResourceAsUsed(resource) {\n    this._usedResources.add(resource);\n  }\n  /**\n   * Finish span, add attributes, network events etc.\n   * @param span\n   * @param spanData\n   * @param response\n   */\n  _endSpan(span, spanData, response) {\n    const endTime = core.millisToHrTime(Date.now());\n    const performanceEndTime = core.hrTime();\n    this._addFinalSpanAttributes(span, response);\n    if (this._semconvStability & SemconvStability.STABLE) {\n      // https://github.com/open-telemetry/semantic-conventions/blob/main/docs/http/http-spans.md#status\n      if (response.status >= 400) {\n        span.setStatus({\n          code: api.SpanStatusCode.ERROR\n        });\n        span.setAttribute(ATTR_ERROR_TYPE, String(response.status));\n      }\n    }\n    setTimeout(() => {\n      spanData.observer?.disconnect();\n      this._findResourceAndAddNetworkEvents(span, spanData, performanceEndTime);\n      this._tasksCount--;\n      this._clearResources();\n      span.end(endTime);\n    }, OBSERVER_WAIT_TIME_MS);\n  }\n  /**\n   * Patches the constructor of fetch\n   */\n  _patchConstructor() {\n    return original => {\n      const plugin = this;\n      return function patchConstructor(...args) {\n        const self = this;\n        const url = web.parseUrl(args[0] instanceof Request ? args[0].url : String(args[0])).href;\n        const options = args[0] instanceof Request ? args[0] : args[1] || {};\n        const createdSpan = plugin._createSpan(url, options);\n        if (!createdSpan) {\n          return original.apply(this, args);\n        }\n        const spanData = plugin._prepareSpanData(url);\n        if (plugin.getConfig().measureRequestSize) {\n          getFetchBodyLength(...args).then(bodyLength => {\n            if (!bodyLength) return;\n            if (plugin._semconvStability & SemconvStability.OLD) {\n              createdSpan.setAttribute(ATTR_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED, bodyLength);\n            }\n            if (plugin._semconvStability & SemconvStability.STABLE) {\n              createdSpan.setAttribute(ATTR_HTTP_REQUEST_BODY_SIZE, bodyLength);\n            }\n          }).catch(error => {\n            plugin._diag.warn('getFetchBodyLength', error);\n          });\n        }\n        function endSpanOnError(span, error) {\n          plugin._applyAttributesAfterFetch(span, options, error);\n          plugin._endSpan(span, spanData, {\n            status: error.status || 0,\n            statusText: error.message,\n            url\n          });\n        }\n        function endSpanOnSuccess(span, response) {\n          plugin._applyAttributesAfterFetch(span, options, response);\n          if (response.status >= 200 && response.status < 400) {\n            plugin._endSpan(span, spanData, response);\n          } else {\n            plugin._endSpan(span, spanData, {\n              status: response.status,\n              statusText: response.statusText,\n              url\n            });\n          }\n        }\n        function onSuccess(span, resolve, response) {\n          try {\n            const resClone = response.clone();\n            const body = resClone.body;\n            if (body) {\n              const reader = body.getReader();\n              const read = () => {\n                reader.read().then(({\n                  done\n                }) => {\n                  if (done) {\n                    endSpanOnSuccess(span, response);\n                  } else {\n                    read();\n                  }\n                }, error => {\n                  endSpanOnError(span, error);\n                });\n              };\n              read();\n            } else {\n              // some older browsers don't have .body implemented\n              endSpanOnSuccess(span, response);\n            }\n          } finally {\n            resolve(response);\n          }\n        }\n        function onError(span, reject, error) {\n          try {\n            endSpanOnError(span, error);\n          } finally {\n            reject(error);\n          }\n        }\n        return new Promise((resolve, reject) => {\n          return api.context.with(api.trace.setSpan(api.context.active(), createdSpan), () => {\n            plugin._addHeaders(options, url);\n            // Important to execute \"_callRequestHook\" after \"_addHeaders\", allowing the consumer code to override the request headers.\n            plugin._callRequestHook(createdSpan, options);\n            plugin._tasksCount++;\n            // TypeScript complains about arrow function captured a this typed as globalThis\n            // ts(7041)\n            return original.apply(self, options instanceof Request ? [options] : [url, options]).then(onSuccess.bind(self, createdSpan, resolve), onError.bind(self, createdSpan, reject));\n          });\n        });\n      };\n    };\n  }\n  _applyAttributesAfterFetch(span, request, result) {\n    const applyCustomAttributesOnSpan = this.getConfig().applyCustomAttributesOnSpan;\n    if (applyCustomAttributesOnSpan) {\n      safeExecuteInTheMiddle(() => applyCustomAttributesOnSpan(span, request, result), error => {\n        if (!error) {\n          return;\n        }\n        this._diag.error('applyCustomAttributesOnSpan', error);\n      }, true);\n    }\n  }\n  _callRequestHook(span, request) {\n    const requestHook = this.getConfig().requestHook;\n    if (requestHook) {\n      safeExecuteInTheMiddle(() => requestHook(span, request), error => {\n        if (!error) {\n          return;\n        }\n        this._diag.error('requestHook', error);\n      }, true);\n    }\n  }\n  /**\n   * Prepares a span data - needed later for matching appropriate network\n   *     resources\n   * @param spanUrl\n   */\n  _prepareSpanData(spanUrl) {\n    const startTime = core.hrTime();\n    const entries = [];\n    if (typeof PerformanceObserver !== 'function') {\n      return {\n        entries,\n        startTime,\n        spanUrl\n      };\n    }\n    const observer = new PerformanceObserver(list => {\n      const perfObsEntries = list.getEntries();\n      perfObsEntries.forEach(entry => {\n        if (entry.initiatorType === 'fetch' && entry.name === spanUrl) {\n          entries.push(entry);\n        }\n      });\n    });\n    observer.observe({\n      entryTypes: ['resource']\n    });\n    return {\n      entries,\n      observer,\n      startTime,\n      spanUrl\n    };\n  }\n  /**\n   * implements enable function\n   */\n  enable() {\n    if (isNode) {\n      // Node.js v18+ *does* have a global `fetch()`, but this package does not\n      // support instrumenting it.\n      this._diag.warn(\"this instrumentation is intended for web usage only, it does not instrument Node.js's fetch()\");\n      return;\n    }\n    if (isWrapped(fetch)) {\n      this._unwrap(_globalThis, 'fetch');\n      this._diag.debug('removing previous patch for constructor');\n    }\n    this._wrap(_globalThis, 'fetch', this._patchConstructor());\n  }\n  /**\n   * implements unpatch function\n   */\n  disable() {\n    if (isNode) {\n      return;\n    }\n    this._unwrap(_globalThis, 'fetch');\n    this._usedResources = new WeakSet();\n  }\n}","map":{"version":3,"names":["api","SemconvStability","semconvStabilityFromStr","isWrapped","InstrumentationBase","safeExecuteInTheMiddle","core","web","AttributeNames","ATTR_HTTP_STATUS_CODE","ATTR_HTTP_HOST","ATTR_HTTP_USER_AGENT","ATTR_HTTP_SCHEME","ATTR_HTTP_URL","ATTR_HTTP_METHOD","ATTR_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED","ATTR_HTTP_REQUEST_BODY_SIZE","ATTR_ERROR_TYPE","ATTR_HTTP_REQUEST_METHOD","ATTR_HTTP_REQUEST_METHOD_ORIGINAL","ATTR_HTTP_RESPONSE_STATUS_CODE","ATTR_SERVER_ADDRESS","ATTR_SERVER_PORT","ATTR_URL_FULL","getFetchBodyLength","normalizeHttpRequestMethod","serverPortFromUrl","VERSION","_globalThis","OBSERVER_WAIT_TIME_MS","isNode","process","release","name","FetchInstrumentation","component","version","moduleName","_usedResources","WeakSet","_tasksCount","_semconvStability","constructor","config","semconvStabilityOptIn","init","_addChildSpan","span","corsPreFlightRequest","childSpan","tracer","startSpan","startTime","PerformanceTimingNames","FETCH_START","trace","setSpan","context","active","skipOldSemconvContentLengthAttrs","OLD","addSpanNetworkEvents","getConfig","ignoreNetworkEvents","undefined","end","RESPONSE_END","_addFinalSpanAttributes","response","parsedUrl","parseUrl","url","setAttribute","status","statusText","HTTP_STATUS_TEXT","host","protocol","replace","navigator","userAgent","STABLE","hostname","serverPort","_addHeaders","options","spanUrl","shouldPropagateTraceHeaders","propagateTraceHeaderCorsUrls","headers","propagation","inject","Object","keys","length","_diag","debug","Request","set","h","k","v","String","Headers","Map","assign","_clearResources","clearTimingResources","performance","clearResourceTimings","_createSpan","isUrlIgnored","ignoreUrls","attributes","method","toUpperCase","COMPONENT","origMethod","normMethod","kind","SpanKind","CLIENT","_findResourceAndAddNetworkEvents","resourcesObserver","endTime","resources","entries","getEntriesByType","resource","getResource","mainRequest","_markResourceAsUsed","add","_endSpan","spanData","millisToHrTime","Date","now","performanceEndTime","hrTime","setStatus","code","SpanStatusCode","ERROR","setTimeout","observer","disconnect","_patchConstructor","original","plugin","patchConstructor","args","self","href","createdSpan","apply","_prepareSpanData","measureRequestSize","then","bodyLength","catch","error","warn","endSpanOnError","_applyAttributesAfterFetch","message","endSpanOnSuccess","onSuccess","resolve","resClone","clone","body","reader","getReader","read","done","onError","reject","Promise","with","_callRequestHook","bind","request","result","applyCustomAttributesOnSpan","requestHook","PerformanceObserver","list","perfObsEntries","getEntries","forEach","entry","initiatorType","push","observe","entryTypes","enable","fetch","_unwrap","_wrap","disable"],"sources":["C:\\Users\\Sartaj\\Desktop\\ObservaCart\\observacart\\frontend\\node_modules\\@opentelemetry\\instrumentation-fetch\\src\\fetch.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as api from '@opentelemetry/api';\nimport {\n  SemconvStability,\n  semconvStabilityFromStr,\n  isWrapped,\n  InstrumentationBase,\n  InstrumentationConfig,\n  safeExecuteInTheMiddle,\n} from '@opentelemetry/instrumentation';\nimport * as core from '@opentelemetry/core';\nimport * as web from '@opentelemetry/sdk-trace-web';\nimport { AttributeNames } from './enums/AttributeNames';\nimport {\n  ATTR_HTTP_STATUS_CODE,\n  ATTR_HTTP_HOST,\n  ATTR_HTTP_USER_AGENT,\n  ATTR_HTTP_SCHEME,\n  ATTR_HTTP_URL,\n  ATTR_HTTP_METHOD,\n  ATTR_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED,\n  ATTR_HTTP_REQUEST_BODY_SIZE,\n} from '../src/semconv';\nimport {\n  ATTR_ERROR_TYPE,\n  ATTR_HTTP_REQUEST_METHOD,\n  ATTR_HTTP_REQUEST_METHOD_ORIGINAL,\n  ATTR_HTTP_RESPONSE_STATUS_CODE,\n  ATTR_SERVER_ADDRESS,\n  ATTR_SERVER_PORT,\n  ATTR_URL_FULL,\n} from '@opentelemetry/semantic-conventions';\nimport { FetchError, FetchResponse, SpanData } from './types';\nimport {\n  getFetchBodyLength,\n  normalizeHttpRequestMethod,\n  serverPortFromUrl,\n} from './utils';\nimport { VERSION } from './version';\nimport { _globalThis } from '@opentelemetry/core';\n\n// how long to wait for observer to collect information about resources\n// this is needed as event \"load\" is called before observer\n// hard to say how long it should really wait, seems like 300ms is\n// safe enough\nconst OBSERVER_WAIT_TIME_MS = 300;\n\nconst isNode = typeof process === 'object' && process.release?.name === 'node';\n\nexport interface FetchCustomAttributeFunction {\n  (\n    span: api.Span,\n    request: Request | RequestInit,\n    result: Response | FetchError\n  ): void;\n}\n\nexport interface FetchRequestHookFunction {\n  (span: api.Span, request: Request | RequestInit): void;\n}\n\n/**\n * FetchPlugin Config\n */\nexport interface FetchInstrumentationConfig extends InstrumentationConfig {\n  // the number of timing resources is limited, after the limit\n  // (chrome 250, safari 150) the information is not collected anymore\n  // the only way to prevent that is to regularly clean the resources\n  // whenever it is possible, this is needed only when PerformanceObserver\n  // is not available\n  clearTimingResources?: boolean;\n  // urls which should include trace headers when origin doesn't match\n  propagateTraceHeaderCorsUrls?: web.PropagateTraceHeaderCorsUrls;\n  /**\n   * URLs that partially match any regex in ignoreUrls will not be traced.\n   * In addition, URLs that are _exact matches_ of strings in ignoreUrls will\n   * also not be traced.\n   */\n  ignoreUrls?: Array<string | RegExp>;\n  /** Function for adding custom attributes on the span */\n  applyCustomAttributesOnSpan?: FetchCustomAttributeFunction;\n  /** Function for adding custom attributes or headers before the request is handled */\n  requestHook?: FetchRequestHookFunction;\n  // Ignore adding network events as span events\n  ignoreNetworkEvents?: boolean;\n  /** Measure outgoing request size */\n  measureRequestSize?: boolean;\n  /** Select the HTTP semantic conventions version(s) used. */\n  semconvStabilityOptIn?: string;\n}\n\n/**\n * This class represents a fetch plugin for auto instrumentation\n */\nexport class FetchInstrumentation extends InstrumentationBase<FetchInstrumentationConfig> {\n  readonly component: string = 'fetch';\n  readonly version: string = VERSION;\n  moduleName = this.component;\n  private _usedResources = new WeakSet<PerformanceResourceTiming>();\n  private _tasksCount = 0;\n\n  private _semconvStability: SemconvStability;\n\n  constructor(config: FetchInstrumentationConfig = {}) {\n    super('@opentelemetry/instrumentation-fetch', VERSION, config);\n    this._semconvStability = semconvStabilityFromStr(\n      'http',\n      config?.semconvStabilityOptIn\n    );\n  }\n\n  init(): void {}\n\n  /**\n   * Add cors pre flight child span\n   * @param span\n   * @param corsPreFlightRequest\n   */\n  private _addChildSpan(\n    span: api.Span,\n    corsPreFlightRequest: PerformanceResourceTiming\n  ): void {\n    const childSpan = this.tracer.startSpan(\n      'CORS Preflight',\n      {\n        startTime: corsPreFlightRequest[web.PerformanceTimingNames.FETCH_START],\n      },\n      api.trace.setSpan(api.context.active(), span)\n    );\n    const skipOldSemconvContentLengthAttrs = !(\n      this._semconvStability & SemconvStability.OLD\n    );\n    web.addSpanNetworkEvents(\n      childSpan,\n      corsPreFlightRequest,\n      this.getConfig().ignoreNetworkEvents,\n      undefined,\n      skipOldSemconvContentLengthAttrs\n    );\n    childSpan.end(\n      corsPreFlightRequest[web.PerformanceTimingNames.RESPONSE_END]\n    );\n  }\n\n  /**\n   * Adds more attributes to span just before ending it\n   * @param span\n   * @param response\n   */\n  private _addFinalSpanAttributes(\n    span: api.Span,\n    response: FetchResponse\n  ): void {\n    const parsedUrl = web.parseUrl(response.url);\n\n    if (this._semconvStability & SemconvStability.OLD) {\n      span.setAttribute(ATTR_HTTP_STATUS_CODE, response.status);\n      if (response.statusText != null) {\n        span.setAttribute(AttributeNames.HTTP_STATUS_TEXT, response.statusText);\n      }\n      span.setAttribute(ATTR_HTTP_HOST, parsedUrl.host);\n      span.setAttribute(ATTR_HTTP_SCHEME, parsedUrl.protocol.replace(':', ''));\n      if (typeof navigator !== 'undefined') {\n        span.setAttribute(ATTR_HTTP_USER_AGENT, navigator.userAgent);\n      }\n    }\n\n    if (this._semconvStability & SemconvStability.STABLE) {\n      span.setAttribute(ATTR_HTTP_RESPONSE_STATUS_CODE, response.status);\n      // TODO: Set server.{address,port} at span creation for sampling decisions\n      // (a \"SHOULD\" requirement in semconv).\n      span.setAttribute(ATTR_SERVER_ADDRESS, parsedUrl.hostname);\n      const serverPort = serverPortFromUrl(parsedUrl);\n      if (serverPort) {\n        span.setAttribute(ATTR_SERVER_PORT, serverPort);\n      }\n    }\n  }\n\n  /**\n   * Add headers\n   * @param options\n   * @param spanUrl\n   */\n  private _addHeaders(options: Request | RequestInit, spanUrl: string): void {\n    if (\n      !web.shouldPropagateTraceHeaders(\n        spanUrl,\n        this.getConfig().propagateTraceHeaderCorsUrls\n      )\n    ) {\n      const headers: Partial<Record<string, unknown>> = {};\n      api.propagation.inject(api.context.active(), headers);\n      if (Object.keys(headers).length > 0) {\n        this._diag.debug('headers inject skipped due to CORS policy');\n      }\n      return;\n    }\n\n    if (options instanceof Request) {\n      api.propagation.inject(api.context.active(), options.headers, {\n        set: (h, k, v) => h.set(k, typeof v === 'string' ? v : String(v)),\n      });\n    } else if (options.headers instanceof Headers) {\n      api.propagation.inject(api.context.active(), options.headers, {\n        set: (h, k, v) => h.set(k, typeof v === 'string' ? v : String(v)),\n      });\n    } else if (options.headers instanceof Map) {\n      api.propagation.inject(api.context.active(), options.headers, {\n        set: (h, k, v) => h.set(k, typeof v === 'string' ? v : String(v)),\n      });\n    } else {\n      const headers: Partial<Record<string, unknown>> = {};\n      api.propagation.inject(api.context.active(), headers);\n      options.headers = Object.assign({}, headers, options.headers || {});\n    }\n  }\n\n  /**\n   * Clears the resource timings and all resources assigned with spans\n   *     when {@link FetchPluginConfig.clearTimingResources} is\n   *     set to true (default false)\n   * @private\n   */\n  private _clearResources() {\n    if (this._tasksCount === 0 && this.getConfig().clearTimingResources) {\n      performance.clearResourceTimings();\n      this._usedResources = new WeakSet<PerformanceResourceTiming>();\n    }\n  }\n\n  /**\n   * Creates a new span\n   * @param url\n   * @param options\n   */\n  private _createSpan(\n    url: string,\n    options: Partial<Request | RequestInit> = {}\n  ): api.Span | undefined {\n    if (core.isUrlIgnored(url, this.getConfig().ignoreUrls)) {\n      this._diag.debug('ignoring span as url matches ignored url');\n      return;\n    }\n\n    let name = '';\n    const attributes = {} as api.Attributes;\n    if (this._semconvStability & SemconvStability.OLD) {\n      const method = (options.method || 'GET').toUpperCase();\n      name = `HTTP ${method}`;\n      attributes[AttributeNames.COMPONENT] = this.moduleName;\n      attributes[ATTR_HTTP_METHOD] = method;\n      attributes[ATTR_HTTP_URL] = url;\n    }\n    if (this._semconvStability & SemconvStability.STABLE) {\n      const origMethod = options.method;\n      const normMethod = normalizeHttpRequestMethod(options.method || 'GET');\n      if (!name) {\n        // The \"old\" span name wins if emitting both old and stable semconv\n        // ('http/dup').\n        name = normMethod;\n      }\n      attributes[ATTR_HTTP_REQUEST_METHOD] = normMethod;\n      if (normMethod !== origMethod) {\n        attributes[ATTR_HTTP_REQUEST_METHOD_ORIGINAL] = origMethod;\n      }\n      attributes[ATTR_URL_FULL] = url;\n    }\n\n    return this.tracer.startSpan(name, {\n      kind: api.SpanKind.CLIENT,\n      attributes,\n    });\n  }\n\n  /**\n   * Finds appropriate resource and add network events to the span\n   * @param span\n   * @param resourcesObserver\n   * @param endTime\n   */\n  private _findResourceAndAddNetworkEvents(\n    span: api.Span,\n    resourcesObserver: SpanData,\n    endTime: api.HrTime\n  ): void {\n    let resources: PerformanceResourceTiming[] = resourcesObserver.entries;\n    if (!resources.length) {\n      if (!performance.getEntriesByType) {\n        return;\n      }\n      // fallback - either Observer is not available or it took longer\n      // then OBSERVER_WAIT_TIME_MS and observer didn't collect enough\n      // information\n      resources = performance.getEntriesByType(\n        'resource'\n      ) as PerformanceResourceTiming[];\n    }\n    const resource = web.getResource(\n      resourcesObserver.spanUrl,\n      resourcesObserver.startTime,\n      endTime,\n      resources,\n      this._usedResources,\n      'fetch'\n    );\n\n    if (resource.mainRequest) {\n      const mainRequest = resource.mainRequest;\n      this._markResourceAsUsed(mainRequest);\n\n      const corsPreFlightRequest = resource.corsPreFlightRequest;\n      if (corsPreFlightRequest) {\n        this._addChildSpan(span, corsPreFlightRequest);\n        this._markResourceAsUsed(corsPreFlightRequest);\n      }\n      const skipOldSemconvContentLengthAttrs = !(\n        this._semconvStability & SemconvStability.OLD\n      );\n      web.addSpanNetworkEvents(\n        span,\n        mainRequest,\n        this.getConfig().ignoreNetworkEvents,\n        undefined,\n        skipOldSemconvContentLengthAttrs\n      );\n    }\n  }\n\n  /**\n   * Marks certain [resource]{@link PerformanceResourceTiming} when information\n   * from this is used to add events to span.\n   * This is done to avoid reusing the same resource again for next span\n   * @param resource\n   */\n  private _markResourceAsUsed(resource: PerformanceResourceTiming): void {\n    this._usedResources.add(resource);\n  }\n\n  /**\n   * Finish span, add attributes, network events etc.\n   * @param span\n   * @param spanData\n   * @param response\n   */\n  private _endSpan(\n    span: api.Span,\n    spanData: SpanData,\n    response: FetchResponse\n  ) {\n    const endTime = core.millisToHrTime(Date.now());\n    const performanceEndTime = core.hrTime();\n    this._addFinalSpanAttributes(span, response);\n\n    if (this._semconvStability & SemconvStability.STABLE) {\n      // https://github.com/open-telemetry/semantic-conventions/blob/main/docs/http/http-spans.md#status\n      if (response.status >= 400) {\n        span.setStatus({ code: api.SpanStatusCode.ERROR });\n        span.setAttribute(ATTR_ERROR_TYPE, String(response.status));\n      }\n    }\n\n    setTimeout(() => {\n      spanData.observer?.disconnect();\n      this._findResourceAndAddNetworkEvents(span, spanData, performanceEndTime);\n      this._tasksCount--;\n      this._clearResources();\n      span.end(endTime);\n    }, OBSERVER_WAIT_TIME_MS);\n  }\n\n  /**\n   * Patches the constructor of fetch\n   */\n  private _patchConstructor(): (original: typeof fetch) => typeof fetch {\n    return original => {\n      const plugin = this;\n      return function patchConstructor(\n        this: typeof globalThis,\n        ...args: Parameters<typeof fetch>\n      ): Promise<Response> {\n        const self = this;\n        const url = web.parseUrl(\n          args[0] instanceof Request ? args[0].url : String(args[0])\n        ).href;\n\n        const options = args[0] instanceof Request ? args[0] : args[1] || {};\n        const createdSpan = plugin._createSpan(url, options);\n        if (!createdSpan) {\n          return original.apply(this, args);\n        }\n        const spanData = plugin._prepareSpanData(url);\n\n        if (plugin.getConfig().measureRequestSize) {\n          getFetchBodyLength(...args)\n            .then(bodyLength => {\n              if (!bodyLength) return;\n\n              if (plugin._semconvStability & SemconvStability.OLD) {\n                createdSpan.setAttribute(\n                  ATTR_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED,\n                  bodyLength\n                );\n              }\n              if (plugin._semconvStability & SemconvStability.STABLE) {\n                createdSpan.setAttribute(\n                  ATTR_HTTP_REQUEST_BODY_SIZE,\n                  bodyLength\n                );\n              }\n            })\n            .catch(error => {\n              plugin._diag.warn('getFetchBodyLength', error);\n            });\n        }\n\n        function endSpanOnError(span: api.Span, error: FetchError) {\n          plugin._applyAttributesAfterFetch(span, options, error);\n          plugin._endSpan(span, spanData, {\n            status: error.status || 0,\n            statusText: error.message,\n            url,\n          });\n        }\n\n        function endSpanOnSuccess(span: api.Span, response: Response) {\n          plugin._applyAttributesAfterFetch(span, options, response);\n          if (response.status >= 200 && response.status < 400) {\n            plugin._endSpan(span, spanData, response);\n          } else {\n            plugin._endSpan(span, spanData, {\n              status: response.status,\n              statusText: response.statusText,\n              url,\n            });\n          }\n        }\n\n        function onSuccess(\n          span: api.Span,\n          resolve: (value: Response | PromiseLike<Response>) => void,\n          response: Response\n        ): void {\n          try {\n            const resClone = response.clone();\n            const body = resClone.body;\n            if (body) {\n              const reader = body.getReader();\n              const read = (): void => {\n                reader.read().then(\n                  ({ done }) => {\n                    if (done) {\n                      endSpanOnSuccess(span, response);\n                    } else {\n                      read();\n                    }\n                  },\n                  error => {\n                    endSpanOnError(span, error);\n                  }\n                );\n              };\n              read();\n            } else {\n              // some older browsers don't have .body implemented\n              endSpanOnSuccess(span, response);\n            }\n          } finally {\n            resolve(response);\n          }\n        }\n\n        function onError(\n          span: api.Span,\n          reject: (reason?: unknown) => void,\n          error: FetchError\n        ) {\n          try {\n            endSpanOnError(span, error);\n          } finally {\n            reject(error);\n          }\n        }\n\n        return new Promise((resolve, reject) => {\n          return api.context.with(\n            api.trace.setSpan(api.context.active(), createdSpan),\n            () => {\n              plugin._addHeaders(options, url);\n              // Important to execute \"_callRequestHook\" after \"_addHeaders\", allowing the consumer code to override the request headers.\n              plugin._callRequestHook(createdSpan, options);\n              plugin._tasksCount++;\n              // TypeScript complains about arrow function captured a this typed as globalThis\n              // ts(7041)\n              return original\n                .apply(\n                  self,\n                  options instanceof Request ? [options] : [url, options]\n                )\n                .then(\n                  onSuccess.bind(self, createdSpan, resolve),\n                  onError.bind(self, createdSpan, reject)\n                );\n            }\n          );\n        });\n      };\n    };\n  }\n\n  private _applyAttributesAfterFetch(\n    span: api.Span,\n    request: Request | RequestInit,\n    result: Response | FetchError\n  ) {\n    const applyCustomAttributesOnSpan =\n      this.getConfig().applyCustomAttributesOnSpan;\n    if (applyCustomAttributesOnSpan) {\n      safeExecuteInTheMiddle(\n        () => applyCustomAttributesOnSpan(span, request, result),\n        error => {\n          if (!error) {\n            return;\n          }\n\n          this._diag.error('applyCustomAttributesOnSpan', error);\n        },\n        true\n      );\n    }\n  }\n\n  private _callRequestHook(span: api.Span, request: Request | RequestInit) {\n    const requestHook = this.getConfig().requestHook;\n    if (requestHook) {\n      safeExecuteInTheMiddle(\n        () => requestHook(span, request),\n        error => {\n          if (!error) {\n            return;\n          }\n\n          this._diag.error('requestHook', error);\n        },\n        true\n      );\n    }\n  }\n\n  /**\n   * Prepares a span data - needed later for matching appropriate network\n   *     resources\n   * @param spanUrl\n   */\n  private _prepareSpanData(spanUrl: string): SpanData {\n    const startTime = core.hrTime();\n    const entries: PerformanceResourceTiming[] = [];\n    if (typeof PerformanceObserver !== 'function') {\n      return { entries, startTime, spanUrl };\n    }\n\n    const observer = new PerformanceObserver(list => {\n      const perfObsEntries = list.getEntries() as PerformanceResourceTiming[];\n      perfObsEntries.forEach(entry => {\n        if (entry.initiatorType === 'fetch' && entry.name === spanUrl) {\n          entries.push(entry);\n        }\n      });\n    });\n    observer.observe({\n      entryTypes: ['resource'],\n    });\n    return { entries, observer, startTime, spanUrl };\n  }\n\n  /**\n   * implements enable function\n   */\n  override enable(): void {\n    if (isNode) {\n      // Node.js v18+ *does* have a global `fetch()`, but this package does not\n      // support instrumenting it.\n      this._diag.warn(\n        \"this instrumentation is intended for web usage only, it does not instrument Node.js's fetch()\"\n      );\n      return;\n    }\n    if (isWrapped(fetch)) {\n      this._unwrap(_globalThis, 'fetch');\n      this._diag.debug('removing previous patch for constructor');\n    }\n    this._wrap(_globalThis, 'fetch', this._patchConstructor());\n  }\n\n  /**\n   * implements unpatch function\n   */\n  override disable(): void {\n    if (isNode) {\n      return;\n    }\n    this._unwrap(_globalThis, 'fetch');\n    this._usedResources = new WeakSet<PerformanceResourceTiming>();\n  }\n}\n"],"mappings":"AAAA;;;;;;;;;;;;;;;AAgBA,OAAO,KAAKA,GAAG,MAAM,oBAAoB;AACzC,SACEC,gBAAgB,EAChBC,uBAAuB,EACvBC,SAAS,EACTC,mBAAmB,EAEnBC,sBAAsB,QACjB,gCAAgC;AACvC,OAAO,KAAKC,IAAI,MAAM,qBAAqB;AAC3C,OAAO,KAAKC,GAAG,MAAM,8BAA8B;AACnD,SAASC,cAAc,QAAQ,wBAAwB;AACvD,SACEC,qBAAqB,EACrBC,cAAc,EACdC,oBAAoB,EACpBC,gBAAgB,EAChBC,aAAa,EACbC,gBAAgB,EAChBC,6CAA6C,EAC7CC,2BAA2B,QACtB,gBAAgB;AACvB,SACEC,eAAe,EACfC,wBAAwB,EACxBC,iCAAiC,EACjCC,8BAA8B,EAC9BC,mBAAmB,EACnBC,gBAAgB,EAChBC,aAAa,QACR,qCAAqC;AAE5C,SACEC,kBAAkB,EAClBC,0BAA0B,EAC1BC,iBAAiB,QACZ,SAAS;AAChB,SAASC,OAAO,QAAQ,WAAW;AACnC,SAASC,WAAW,QAAQ,qBAAqB;AAEjD;AACA;AACA;AACA;AACA,MAAMC,qBAAqB,GAAG,GAAG;AAEjC,MAAMC,MAAM,GAAG,OAAOC,OAAO,KAAK,QAAQ,IAAIA,OAAO,CAACC,OAAO,EAAEC,IAAI,KAAK,MAAM;AA4C9E;;;AAGA,OAAM,MAAOC,oBAAqB,SAAQ9B,mBAA+C;EAC9E+B,SAAS,GAAW,OAAO;EAC3BC,OAAO,GAAWT,OAAO;EAClCU,UAAU,GAAG,IAAI,CAACF,SAAS;EACnBG,cAAc,GAAG,IAAIC,OAAO,EAA6B;EACzDC,WAAW,GAAG,CAAC;EAEfC,iBAAiB;EAEzBC,YAAYC,MAAA,GAAqC,EAAE;IACjD,KAAK,CAAC,sCAAsC,EAAEhB,OAAO,EAAEgB,MAAM,CAAC;IAC9D,IAAI,CAACF,iBAAiB,GAAGvC,uBAAuB,CAC9C,MAAM,EACNyC,MAAM,EAAEC,qBAAqB,CAC9B;EACH;EAEAC,IAAIA,CAAA,GAAU;EAEd;;;;;EAKQC,aAAaA,CACnBC,IAAc,EACdC,oBAA+C;IAE/C,MAAMC,SAAS,GAAG,IAAI,CAACC,MAAM,CAACC,SAAS,CACrC,gBAAgB,EAChB;MACEC,SAAS,EAAEJ,oBAAoB,CAACzC,GAAG,CAAC8C,sBAAsB,CAACC,WAAW;KACvE,EACDtD,GAAG,CAACuD,KAAK,CAACC,OAAO,CAACxD,GAAG,CAACyD,OAAO,CAACC,MAAM,EAAE,EAAEX,IAAI,CAAC,CAC9C;IACD,MAAMY,gCAAgC,GAAG,EACvC,IAAI,CAAClB,iBAAiB,GAAGxC,gBAAgB,CAAC2D,GAAG,CAC9C;IACDrD,GAAG,CAACsD,oBAAoB,CACtBZ,SAAS,EACTD,oBAAoB,EACpB,IAAI,CAACc,SAAS,EAAE,CAACC,mBAAmB,EACpCC,SAAS,EACTL,gCAAgC,CACjC;IACDV,SAAS,CAACgB,GAAG,CACXjB,oBAAoB,CAACzC,GAAG,CAAC8C,sBAAsB,CAACa,YAAY,CAAC,CAC9D;EACH;EAEA;;;;;EAKQC,uBAAuBA,CAC7BpB,IAAc,EACdqB,QAAuB;IAEvB,MAAMC,SAAS,GAAG9D,GAAG,CAAC+D,QAAQ,CAACF,QAAQ,CAACG,GAAG,CAAC;IAE5C,IAAI,IAAI,CAAC9B,iBAAiB,GAAGxC,gBAAgB,CAAC2D,GAAG,EAAE;MACjDb,IAAI,CAACyB,YAAY,CAAC/D,qBAAqB,EAAE2D,QAAQ,CAACK,MAAM,CAAC;MACzD,IAAIL,QAAQ,CAACM,UAAU,IAAI,IAAI,EAAE;QAC/B3B,IAAI,CAACyB,YAAY,CAAChE,cAAc,CAACmE,gBAAgB,EAAEP,QAAQ,CAACM,UAAU,CAAC;;MAEzE3B,IAAI,CAACyB,YAAY,CAAC9D,cAAc,EAAE2D,SAAS,CAACO,IAAI,CAAC;MACjD7B,IAAI,CAACyB,YAAY,CAAC5D,gBAAgB,EAAEyD,SAAS,CAACQ,QAAQ,CAACC,OAAO,CAAC,GAAG,EAAE,EAAE,CAAC,CAAC;MACxE,IAAI,OAAOC,SAAS,KAAK,WAAW,EAAE;QACpChC,IAAI,CAACyB,YAAY,CAAC7D,oBAAoB,EAAEoE,SAAS,CAACC,SAAS,CAAC;;;IAIhE,IAAI,IAAI,CAACvC,iBAAiB,GAAGxC,gBAAgB,CAACgF,MAAM,EAAE;MACpDlC,IAAI,CAACyB,YAAY,CAACpD,8BAA8B,EAAEgD,QAAQ,CAACK,MAAM,CAAC;MAClE;MACA;MACA1B,IAAI,CAACyB,YAAY,CAACnD,mBAAmB,EAAEgD,SAAS,CAACa,QAAQ,CAAC;MAC1D,MAAMC,UAAU,GAAGzD,iBAAiB,CAAC2C,SAAS,CAAC;MAC/C,IAAIc,UAAU,EAAE;QACdpC,IAAI,CAACyB,YAAY,CAAClD,gBAAgB,EAAE6D,UAAU,CAAC;;;EAGrD;EAEA;;;;;EAKQC,WAAWA,CAACC,OAA8B,EAAEC,OAAe;IACjE,IACE,CAAC/E,GAAG,CAACgF,2BAA2B,CAC9BD,OAAO,EACP,IAAI,CAACxB,SAAS,EAAE,CAAC0B,4BAA4B,CAC9C,EACD;MACA,MAAMC,OAAO,GAAqC,EAAE;MACpDzF,GAAG,CAAC0F,WAAW,CAACC,MAAM,CAAC3F,GAAG,CAACyD,OAAO,CAACC,MAAM,EAAE,EAAE+B,OAAO,CAAC;MACrD,IAAIG,MAAM,CAACC,IAAI,CAACJ,OAAO,CAAC,CAACK,MAAM,GAAG,CAAC,EAAE;QACnC,IAAI,CAACC,KAAK,CAACC,KAAK,CAAC,2CAA2C,CAAC;;MAE/D;;IAGF,IAAIX,OAAO,YAAYY,OAAO,EAAE;MAC9BjG,GAAG,CAAC0F,WAAW,CAACC,MAAM,CAAC3F,GAAG,CAACyD,OAAO,CAACC,MAAM,EAAE,EAAE2B,OAAO,CAACI,OAAO,EAAE;QAC5DS,GAAG,EAAEA,CAACC,CAAC,EAAEC,CAAC,EAAEC,CAAC,KAAKF,CAAC,CAACD,GAAG,CAACE,CAAC,EAAE,OAAOC,CAAC,KAAK,QAAQ,GAAGA,CAAC,GAAGC,MAAM,CAACD,CAAC,CAAC;OACjE,CAAC;KACH,MAAM,IAAIhB,OAAO,CAACI,OAAO,YAAYc,OAAO,EAAE;MAC7CvG,GAAG,CAAC0F,WAAW,CAACC,MAAM,CAAC3F,GAAG,CAACyD,OAAO,CAACC,MAAM,EAAE,EAAE2B,OAAO,CAACI,OAAO,EAAE;QAC5DS,GAAG,EAAEA,CAACC,CAAC,EAAEC,CAAC,EAAEC,CAAC,KAAKF,CAAC,CAACD,GAAG,CAACE,CAAC,EAAE,OAAOC,CAAC,KAAK,QAAQ,GAAGA,CAAC,GAAGC,MAAM,CAACD,CAAC,CAAC;OACjE,CAAC;KACH,MAAM,IAAIhB,OAAO,CAACI,OAAO,YAAYe,GAAG,EAAE;MACzCxG,GAAG,CAAC0F,WAAW,CAACC,MAAM,CAAC3F,GAAG,CAACyD,OAAO,CAACC,MAAM,EAAE,EAAE2B,OAAO,CAACI,OAAO,EAAE;QAC5DS,GAAG,EAAEA,CAACC,CAAC,EAAEC,CAAC,EAAEC,CAAC,KAAKF,CAAC,CAACD,GAAG,CAACE,CAAC,EAAE,OAAOC,CAAC,KAAK,QAAQ,GAAGA,CAAC,GAAGC,MAAM,CAACD,CAAC,CAAC;OACjE,CAAC;KACH,MAAM;MACL,MAAMZ,OAAO,GAAqC,EAAE;MACpDzF,GAAG,CAAC0F,WAAW,CAACC,MAAM,CAAC3F,GAAG,CAACyD,OAAO,CAACC,MAAM,EAAE,EAAE+B,OAAO,CAAC;MACrDJ,OAAO,CAACI,OAAO,GAAGG,MAAM,CAACa,MAAM,CAAC,EAAE,EAAEhB,OAAO,EAAEJ,OAAO,CAACI,OAAO,IAAI,EAAE,CAAC;;EAEvE;EAEA;;;;;;EAMQiB,eAAeA,CAAA;IACrB,IAAI,IAAI,CAAClE,WAAW,KAAK,CAAC,IAAI,IAAI,CAACsB,SAAS,EAAE,CAAC6C,oBAAoB,EAAE;MACnEC,WAAW,CAACC,oBAAoB,EAAE;MAClC,IAAI,CAACvE,cAAc,GAAG,IAAIC,OAAO,EAA6B;;EAElE;EAEA;;;;;EAKQuE,WAAWA,CACjBvC,GAAW,EACXc,OAAA,GAA0C,EAAE;IAE5C,IAAI/E,IAAI,CAACyG,YAAY,CAACxC,GAAG,EAAE,IAAI,CAACT,SAAS,EAAE,CAACkD,UAAU,CAAC,EAAE;MACvD,IAAI,CAACjB,KAAK,CAACC,KAAK,CAAC,0CAA0C,CAAC;MAC5D;;IAGF,IAAI/D,IAAI,GAAG,EAAE;IACb,MAAMgF,UAAU,GAAG,EAAoB;IACvC,IAAI,IAAI,CAACxE,iBAAiB,GAAGxC,gBAAgB,CAAC2D,GAAG,EAAE;MACjD,MAAMsD,MAAM,GAAG,CAAC7B,OAAO,CAAC6B,MAAM,IAAI,KAAK,EAAEC,WAAW,EAAE;MACtDlF,IAAI,GAAG,QAAQiF,MAAM,EAAE;MACvBD,UAAU,CAACzG,cAAc,CAAC4G,SAAS,CAAC,GAAG,IAAI,CAAC/E,UAAU;MACtD4E,UAAU,CAACnG,gBAAgB,CAAC,GAAGoG,MAAM;MACrCD,UAAU,CAACpG,aAAa,CAAC,GAAG0D,GAAG;;IAEjC,IAAI,IAAI,CAAC9B,iBAAiB,GAAGxC,gBAAgB,CAACgF,MAAM,EAAE;MACpD,MAAMoC,UAAU,GAAGhC,OAAO,CAAC6B,MAAM;MACjC,MAAMI,UAAU,GAAG7F,0BAA0B,CAAC4D,OAAO,CAAC6B,MAAM,IAAI,KAAK,CAAC;MACtE,IAAI,CAACjF,IAAI,EAAE;QACT;QACA;QACAA,IAAI,GAAGqF,UAAU;;MAEnBL,UAAU,CAAC/F,wBAAwB,CAAC,GAAGoG,UAAU;MACjD,IAAIA,UAAU,KAAKD,UAAU,EAAE;QAC7BJ,UAAU,CAAC9F,iCAAiC,CAAC,GAAGkG,UAAU;;MAE5DJ,UAAU,CAAC1F,aAAa,CAAC,GAAGgD,GAAG;;IAGjC,OAAO,IAAI,CAACrB,MAAM,CAACC,SAAS,CAAClB,IAAI,EAAE;MACjCsF,IAAI,EAAEvH,GAAG,CAACwH,QAAQ,CAACC,MAAM;MACzBR;KACD,CAAC;EACJ;EAEA;;;;;;EAMQS,gCAAgCA,CACtC3E,IAAc,EACd4E,iBAA2B,EAC3BC,OAAmB;IAEnB,IAAIC,SAAS,GAAgCF,iBAAiB,CAACG,OAAO;IACtE,IAAI,CAACD,SAAS,CAAC/B,MAAM,EAAE;MACrB,IAAI,CAACc,WAAW,CAACmB,gBAAgB,EAAE;QACjC;;MAEF;MACA;MACA;MACAF,SAAS,GAAGjB,WAAW,CAACmB,gBAAgB,CACtC,UAAU,CACoB;;IAElC,MAAMC,QAAQ,GAAGzH,GAAG,CAAC0H,WAAW,CAC9BN,iBAAiB,CAACrC,OAAO,EACzBqC,iBAAiB,CAACvE,SAAS,EAC3BwE,OAAO,EACPC,SAAS,EACT,IAAI,CAACvF,cAAc,EACnB,OAAO,CACR;IAED,IAAI0F,QAAQ,CAACE,WAAW,EAAE;MACxB,MAAMA,WAAW,GAAGF,QAAQ,CAACE,WAAW;MACxC,IAAI,CAACC,mBAAmB,CAACD,WAAW,CAAC;MAErC,MAAMlF,oBAAoB,GAAGgF,QAAQ,CAAChF,oBAAoB;MAC1D,IAAIA,oBAAoB,EAAE;QACxB,IAAI,CAACF,aAAa,CAACC,IAAI,EAAEC,oBAAoB,CAAC;QAC9C,IAAI,CAACmF,mBAAmB,CAACnF,oBAAoB,CAAC;;MAEhD,MAAMW,gCAAgC,GAAG,EACvC,IAAI,CAAClB,iBAAiB,GAAGxC,gBAAgB,CAAC2D,GAAG,CAC9C;MACDrD,GAAG,CAACsD,oBAAoB,CACtBd,IAAI,EACJmF,WAAW,EACX,IAAI,CAACpE,SAAS,EAAE,CAACC,mBAAmB,EACpCC,SAAS,EACTL,gCAAgC,CACjC;;EAEL;EAEA;;;;;;EAMQwE,mBAAmBA,CAACH,QAAmC;IAC7D,IAAI,CAAC1F,cAAc,CAAC8F,GAAG,CAACJ,QAAQ,CAAC;EACnC;EAEA;;;;;;EAMQK,QAAQA,CACdtF,IAAc,EACduF,QAAkB,EAClBlE,QAAuB;IAEvB,MAAMwD,OAAO,GAAGtH,IAAI,CAACiI,cAAc,CAACC,IAAI,CAACC,GAAG,EAAE,CAAC;IAC/C,MAAMC,kBAAkB,GAAGpI,IAAI,CAACqI,MAAM,EAAE;IACxC,IAAI,CAACxE,uBAAuB,CAACpB,IAAI,EAAEqB,QAAQ,CAAC;IAE5C,IAAI,IAAI,CAAC3B,iBAAiB,GAAGxC,gBAAgB,CAACgF,MAAM,EAAE;MACpD;MACA,IAAIb,QAAQ,CAACK,MAAM,IAAI,GAAG,EAAE;QAC1B1B,IAAI,CAAC6F,SAAS,CAAC;UAAEC,IAAI,EAAE7I,GAAG,CAAC8I,cAAc,CAACC;QAAK,CAAE,CAAC;QAClDhG,IAAI,CAACyB,YAAY,CAACvD,eAAe,EAAEqF,MAAM,CAAClC,QAAQ,CAACK,MAAM,CAAC,CAAC;;;IAI/DuE,UAAU,CAAC,MAAK;MACdV,QAAQ,CAACW,QAAQ,EAAEC,UAAU,EAAE;MAC/B,IAAI,CAACxB,gCAAgC,CAAC3E,IAAI,EAAEuF,QAAQ,EAAEI,kBAAkB,CAAC;MACzE,IAAI,CAAClG,WAAW,EAAE;MAClB,IAAI,CAACkE,eAAe,EAAE;MACtB3D,IAAI,CAACkB,GAAG,CAAC2D,OAAO,CAAC;IACnB,CAAC,EAAE/F,qBAAqB,CAAC;EAC3B;EAEA;;;EAGQsH,iBAAiBA,CAAA;IACvB,OAAOC,QAAQ,IAAG;MAChB,MAAMC,MAAM,GAAG,IAAI;MACnB,OAAO,SAASC,gBAAgBA,CAE9B,GAAGC,IAA8B;QAEjC,MAAMC,IAAI,GAAG,IAAI;QACjB,MAAMjF,GAAG,GAAGhE,GAAG,CAAC+D,QAAQ,CACtBiF,IAAI,CAAC,CAAC,CAAC,YAAYtD,OAAO,GAAGsD,IAAI,CAAC,CAAC,CAAC,CAAChF,GAAG,GAAG+B,MAAM,CAACiD,IAAI,CAAC,CAAC,CAAC,CAAC,CAC3D,CAACE,IAAI;QAEN,MAAMpE,OAAO,GAAGkE,IAAI,CAAC,CAAC,CAAC,YAAYtD,OAAO,GAAGsD,IAAI,CAAC,CAAC,CAAC,GAAGA,IAAI,CAAC,CAAC,CAAC,IAAI,EAAE;QACpE,MAAMG,WAAW,GAAGL,MAAM,CAACvC,WAAW,CAACvC,GAAG,EAAEc,OAAO,CAAC;QACpD,IAAI,CAACqE,WAAW,EAAE;UAChB,OAAON,QAAQ,CAACO,KAAK,CAAC,IAAI,EAAEJ,IAAI,CAAC;;QAEnC,MAAMjB,QAAQ,GAAGe,MAAM,CAACO,gBAAgB,CAACrF,GAAG,CAAC;QAE7C,IAAI8E,MAAM,CAACvF,SAAS,EAAE,CAAC+F,kBAAkB,EAAE;UACzCrI,kBAAkB,CAAC,GAAG+H,IAAI,CAAC,CACxBO,IAAI,CAACC,UAAU,IAAG;YACjB,IAAI,CAACA,UAAU,EAAE;YAEjB,IAAIV,MAAM,CAAC5G,iBAAiB,GAAGxC,gBAAgB,CAAC2D,GAAG,EAAE;cACnD8F,WAAW,CAAClF,YAAY,CACtBzD,6CAA6C,EAC7CgJ,UAAU,CACX;;YAEH,IAAIV,MAAM,CAAC5G,iBAAiB,GAAGxC,gBAAgB,CAACgF,MAAM,EAAE;cACtDyE,WAAW,CAAClF,YAAY,CACtBxD,2BAA2B,EAC3B+I,UAAU,CACX;;UAEL,CAAC,CAAC,CACDC,KAAK,CAACC,KAAK,IAAG;YACbZ,MAAM,CAACtD,KAAK,CAACmE,IAAI,CAAC,oBAAoB,EAAED,KAAK,CAAC;UAChD,CAAC,CAAC;;QAGN,SAASE,cAAcA,CAACpH,IAAc,EAAEkH,KAAiB;UACvDZ,MAAM,CAACe,0BAA0B,CAACrH,IAAI,EAAEsC,OAAO,EAAE4E,KAAK,CAAC;UACvDZ,MAAM,CAAChB,QAAQ,CAACtF,IAAI,EAAEuF,QAAQ,EAAE;YAC9B7D,MAAM,EAAEwF,KAAK,CAACxF,MAAM,IAAI,CAAC;YACzBC,UAAU,EAAEuF,KAAK,CAACI,OAAO;YACzB9F;WACD,CAAC;QACJ;QAEA,SAAS+F,gBAAgBA,CAACvH,IAAc,EAAEqB,QAAkB;UAC1DiF,MAAM,CAACe,0BAA0B,CAACrH,IAAI,EAAEsC,OAAO,EAAEjB,QAAQ,CAAC;UAC1D,IAAIA,QAAQ,CAACK,MAAM,IAAI,GAAG,IAAIL,QAAQ,CAACK,MAAM,GAAG,GAAG,EAAE;YACnD4E,MAAM,CAAChB,QAAQ,CAACtF,IAAI,EAAEuF,QAAQ,EAAElE,QAAQ,CAAC;WAC1C,MAAM;YACLiF,MAAM,CAAChB,QAAQ,CAACtF,IAAI,EAAEuF,QAAQ,EAAE;cAC9B7D,MAAM,EAAEL,QAAQ,CAACK,MAAM;cACvBC,UAAU,EAAEN,QAAQ,CAACM,UAAU;cAC/BH;aACD,CAAC;;QAEN;QAEA,SAASgG,SAASA,CAChBxH,IAAc,EACdyH,OAA0D,EAC1DpG,QAAkB;UAElB,IAAI;YACF,MAAMqG,QAAQ,GAAGrG,QAAQ,CAACsG,KAAK,EAAE;YACjC,MAAMC,IAAI,GAAGF,QAAQ,CAACE,IAAI;YAC1B,IAAIA,IAAI,EAAE;cACR,MAAMC,MAAM,GAAGD,IAAI,CAACE,SAAS,EAAE;cAC/B,MAAMC,IAAI,GAAGA,CAAA,KAAW;gBACtBF,MAAM,CAACE,IAAI,EAAE,CAAChB,IAAI,CAChB,CAAC;kBAAEiB;gBAAI,CAAE,KAAI;kBACX,IAAIA,IAAI,EAAE;oBACRT,gBAAgB,CAACvH,IAAI,EAAEqB,QAAQ,CAAC;mBACjC,MAAM;oBACL0G,IAAI,EAAE;;gBAEV,CAAC,EACDb,KAAK,IAAG;kBACNE,cAAc,CAACpH,IAAI,EAAEkH,KAAK,CAAC;gBAC7B,CAAC,CACF;cACH,CAAC;cACDa,IAAI,EAAE;aACP,MAAM;cACL;cACAR,gBAAgB,CAACvH,IAAI,EAAEqB,QAAQ,CAAC;;WAEnC,SAAS;YACRoG,OAAO,CAACpG,QAAQ,CAAC;;QAErB;QAEA,SAAS4G,OAAOA,CACdjI,IAAc,EACdkI,MAAkC,EAClChB,KAAiB;UAEjB,IAAI;YACFE,cAAc,CAACpH,IAAI,EAAEkH,KAAK,CAAC;WAC5B,SAAS;YACRgB,MAAM,CAAChB,KAAK,CAAC;;QAEjB;QAEA,OAAO,IAAIiB,OAAO,CAAC,CAACV,OAAO,EAAES,MAAM,KAAI;UACrC,OAAOjL,GAAG,CAACyD,OAAO,CAAC0H,IAAI,CACrBnL,GAAG,CAACuD,KAAK,CAACC,OAAO,CAACxD,GAAG,CAACyD,OAAO,CAACC,MAAM,EAAE,EAAEgG,WAAW,CAAC,EACpD,MAAK;YACHL,MAAM,CAACjE,WAAW,CAACC,OAAO,EAAEd,GAAG,CAAC;YAChC;YACA8E,MAAM,CAAC+B,gBAAgB,CAAC1B,WAAW,EAAErE,OAAO,CAAC;YAC7CgE,MAAM,CAAC7G,WAAW,EAAE;YACpB;YACA;YACA,OAAO4G,QAAQ,CACZO,KAAK,CACJH,IAAI,EACJnE,OAAO,YAAYY,OAAO,GAAG,CAACZ,OAAO,CAAC,GAAG,CAACd,GAAG,EAAEc,OAAO,CAAC,CACxD,CACAyE,IAAI,CACHS,SAAS,CAACc,IAAI,CAAC7B,IAAI,EAAEE,WAAW,EAAEc,OAAO,CAAC,EAC1CQ,OAAO,CAACK,IAAI,CAAC7B,IAAI,EAAEE,WAAW,EAAEuB,MAAM,CAAC,CACxC;UACL,CAAC,CACF;QACH,CAAC,CAAC;MACJ,CAAC;IACH,CAAC;EACH;EAEQb,0BAA0BA,CAChCrH,IAAc,EACduI,OAA8B,EAC9BC,MAA6B;IAE7B,MAAMC,2BAA2B,GAC/B,IAAI,CAAC1H,SAAS,EAAE,CAAC0H,2BAA2B;IAC9C,IAAIA,2BAA2B,EAAE;MAC/BnL,sBAAsB,CACpB,MAAMmL,2BAA2B,CAACzI,IAAI,EAAEuI,OAAO,EAAEC,MAAM,CAAC,EACxDtB,KAAK,IAAG;QACN,IAAI,CAACA,KAAK,EAAE;UACV;;QAGF,IAAI,CAAClE,KAAK,CAACkE,KAAK,CAAC,6BAA6B,EAAEA,KAAK,CAAC;MACxD,CAAC,EACD,IAAI,CACL;;EAEL;EAEQmB,gBAAgBA,CAACrI,IAAc,EAAEuI,OAA8B;IACrE,MAAMG,WAAW,GAAG,IAAI,CAAC3H,SAAS,EAAE,CAAC2H,WAAW;IAChD,IAAIA,WAAW,EAAE;MACfpL,sBAAsB,CACpB,MAAMoL,WAAW,CAAC1I,IAAI,EAAEuI,OAAO,CAAC,EAChCrB,KAAK,IAAG;QACN,IAAI,CAACA,KAAK,EAAE;UACV;;QAGF,IAAI,CAAClE,KAAK,CAACkE,KAAK,CAAC,aAAa,EAAEA,KAAK,CAAC;MACxC,CAAC,EACD,IAAI,CACL;;EAEL;EAEA;;;;;EAKQL,gBAAgBA,CAACtE,OAAe;IACtC,MAAMlC,SAAS,GAAG9C,IAAI,CAACqI,MAAM,EAAE;IAC/B,MAAMb,OAAO,GAAgC,EAAE;IAC/C,IAAI,OAAO4D,mBAAmB,KAAK,UAAU,EAAE;MAC7C,OAAO;QAAE5D,OAAO;QAAE1E,SAAS;QAAEkC;MAAO,CAAE;;IAGxC,MAAM2D,QAAQ,GAAG,IAAIyC,mBAAmB,CAACC,IAAI,IAAG;MAC9C,MAAMC,cAAc,GAAGD,IAAI,CAACE,UAAU,EAAiC;MACvED,cAAc,CAACE,OAAO,CAACC,KAAK,IAAG;QAC7B,IAAIA,KAAK,CAACC,aAAa,KAAK,OAAO,IAAID,KAAK,CAAC9J,IAAI,KAAKqD,OAAO,EAAE;UAC7DwC,OAAO,CAACmE,IAAI,CAACF,KAAK,CAAC;;MAEvB,CAAC,CAAC;IACJ,CAAC,CAAC;IACF9C,QAAQ,CAACiD,OAAO,CAAC;MACfC,UAAU,EAAE,CAAC,UAAU;KACxB,CAAC;IACF,OAAO;MAAErE,OAAO;MAAEmB,QAAQ;MAAE7F,SAAS;MAAEkC;IAAO,CAAE;EAClD;EAEA;;;EAGS8G,MAAMA,CAAA;IACb,IAAItK,MAAM,EAAE;MACV;MACA;MACA,IAAI,CAACiE,KAAK,CAACmE,IAAI,CACb,+FAA+F,CAChG;MACD;;IAEF,IAAI/J,SAAS,CAACkM,KAAK,CAAC,EAAE;MACpB,IAAI,CAACC,OAAO,CAAC1K,WAAW,EAAE,OAAO,CAAC;MAClC,IAAI,CAACmE,KAAK,CAACC,KAAK,CAAC,yCAAyC,CAAC;;IAE7D,IAAI,CAACuG,KAAK,CAAC3K,WAAW,EAAE,OAAO,EAAE,IAAI,CAACuH,iBAAiB,EAAE,CAAC;EAC5D;EAEA;;;EAGSqD,OAAOA,CAAA;IACd,IAAI1K,MAAM,EAAE;MACV;;IAEF,IAAI,CAACwK,OAAO,CAAC1K,WAAW,EAAE,OAAO,CAAC;IAClC,IAAI,CAACU,cAAc,GAAG,IAAIC,OAAO,EAA6B;EAChE","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}