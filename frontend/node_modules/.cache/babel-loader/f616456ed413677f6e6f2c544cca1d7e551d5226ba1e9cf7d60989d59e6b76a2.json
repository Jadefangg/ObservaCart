{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/** The kind of metric. */\nexport var MetricKind;\n(function (MetricKind) {\n  MetricKind[MetricKind[\"COUNTER\"] = 0] = \"COUNTER\";\n  MetricKind[MetricKind[\"UP_DOWN_COUNTER\"] = 1] = \"UP_DOWN_COUNTER\";\n  MetricKind[MetricKind[\"VALUE_RECORDER\"] = 2] = \"VALUE_RECORDER\";\n  MetricKind[MetricKind[\"SUM_OBSERVER\"] = 3] = \"SUM_OBSERVER\";\n  MetricKind[MetricKind[\"UP_DOWN_SUM_OBSERVER\"] = 4] = \"UP_DOWN_SUM_OBSERVER\";\n  MetricKind[MetricKind[\"VALUE_OBSERVER\"] = 5] = \"VALUE_OBSERVER\";\n  MetricKind[MetricKind[\"BATCH_OBSERVER\"] = 6] = \"BATCH_OBSERVER\";\n})(MetricKind || (MetricKind = {}));\nexport var MetricKindValues = Object.values(MetricKind);\n/** The kind of aggregator. */\nexport var AggregatorKind;\n(function (AggregatorKind) {\n  AggregatorKind[AggregatorKind[\"SUM\"] = 0] = \"SUM\";\n  AggregatorKind[AggregatorKind[\"LAST_VALUE\"] = 1] = \"LAST_VALUE\";\n  AggregatorKind[AggregatorKind[\"HISTOGRAM\"] = 2] = \"HISTOGRAM\";\n})(AggregatorKind || (AggregatorKind = {}));","map":{"version":3,"names":["MetricKind","MetricKindValues","Object","values","AggregatorKind"],"sources":["C:\\Users\\Sartaj\\Desktop\\ObservaCart\\observacart\\frontend\\node_modules\\@opentelemetry\\sdk-metrics-base\\src\\export\\types.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { HrTime } from '@opentelemetry/api';\nimport {\n  Labels,\n  AggregationTemporality,\n  ValueType,\n} from '@opentelemetry/api-metrics';\nimport { ExportResult, InstrumentationLibrary } from '@opentelemetry/core';\nimport { Resource } from '@opentelemetry/resources';\n\n/** The kind of metric. */\nexport enum MetricKind {\n  COUNTER,\n  UP_DOWN_COUNTER,\n  VALUE_RECORDER,\n  SUM_OBSERVER,\n  UP_DOWN_SUM_OBSERVER,\n  VALUE_OBSERVER,\n  BATCH_OBSERVER,\n}\n\nexport const MetricKindValues = Object.values(MetricKind);\n\n/** The kind of aggregator. */\nexport enum AggregatorKind {\n  SUM,\n  LAST_VALUE,\n  HISTOGRAM,\n}\n\n/** Sum returns an aggregated sum. */\nexport type Sum = number;\n\n/** LastValue returns last value. */\nexport type LastValue = number;\n\nexport interface Histogram {\n  /**\n   * Buckets are implemented using two different arrays:\n   *  - boundaries: contains every finite bucket boundary, which are inclusive lower bounds\n   *  - counts: contains event counts for each bucket\n   *\n   * Note that we'll always have n+1 buckets, where n is the number of boundaries.\n   * This is because we need to count events that are below the lowest boundary.\n   *\n   * Example: if we measure the values: [5, 30, 5, 40, 5, 15, 15, 15, 25]\n   *  with the boundaries [ 10, 20, 30 ], we will have the following state:\n   *\n   * buckets: {\n   *\tboundaries: [10, 20, 30],\n   *\tcounts: [3, 3, 1, 2],\n   * }\n   */\n  buckets: {\n    boundaries: number[];\n    counts: number[];\n  };\n  sum: number;\n  count: number;\n}\n\nexport type PointValueType = Sum | LastValue | Histogram;\n\nexport interface MetricRecord {\n  readonly descriptor: MetricDescriptor;\n  readonly labels: Labels;\n  readonly aggregator: Aggregator;\n  readonly aggregationTemporality: AggregationTemporality;\n  readonly resource: Resource;\n  readonly instrumentationLibrary: InstrumentationLibrary;\n}\n\nexport interface MetricDescriptor {\n  readonly name: string;\n  readonly description: string;\n  readonly unit: string;\n  readonly metricKind: MetricKind;\n  readonly valueType: ValueType;\n  readonly boundaries?: number[];\n}\n\n/**\n * Base interface that represents a metric exporter\n */\nexport interface MetricExporter {\n  /** Exports the list of a given {@link MetricRecord} */\n  export(\n    metrics: MetricRecord[],\n    resultCallback: (result: ExportResult) => void\n  ): void;\n\n  /** Stops the exporter. */\n  shutdown(): Promise<void>;\n}\n\n/**\n * Base interface for aggregators. Aggregators are responsible for holding\n * aggregated values and taking a snapshot of these values upon export.\n *\n * Use {@link Aggregator} instead of this BaseAggregator.\n */\ninterface BaseAggregator {\n  /** The kind of the aggregator. */\n  kind: AggregatorKind;\n\n  /** Updates the current with the new value. */\n  update(value: number): void;\n}\n\n/** SumAggregatorType aggregate values into a {@link Sum} point type. */\nexport interface SumAggregatorType extends BaseAggregator {\n  kind: AggregatorKind.SUM;\n\n  /** Returns snapshot of the current point (value with timestamp). */\n  toPoint(): Point<Sum>;\n}\n\n/**\n * LastValueAggregatorType aggregate values into a {@link LastValue} point\n * type.\n */\nexport interface LastValueAggregatorType extends BaseAggregator {\n  kind: AggregatorKind.LAST_VALUE;\n\n  /** Returns snapshot of the current point (value with timestamp). */\n  toPoint(): Point<LastValue>;\n}\n\n/**\n * HistogramAggregatorType aggregate values into a {@link Histogram} point\n * type.\n */\nexport interface HistogramAggregatorType extends BaseAggregator {\n  kind: AggregatorKind.HISTOGRAM;\n\n  /** Returns snapshot of the current point (value with timestamp). */\n  toPoint(): Point<Histogram>;\n}\n\nexport type Aggregator =\n  | SumAggregatorType\n  | LastValueAggregatorType\n  | HistogramAggregatorType;\n\n/**\n * Point represents a snapshot of aggregated values of aggregators.\n */\nexport interface Point<T extends PointValueType> {\n  value: T;\n  timestamp: HrTime;\n}\n"],"mappings":"AAAA;;;;;;;;;;;;;;;AAyBA;AACA,WAAYA,UAQX;AARD,WAAYA,UAAU;EACpBA,UAAA,CAAAA,UAAA,4BAAO;EACPA,UAAA,CAAAA,UAAA,4CAAe;EACfA,UAAA,CAAAA,UAAA,0CAAc;EACdA,UAAA,CAAAA,UAAA,sCAAY;EACZA,UAAA,CAAAA,UAAA,sDAAoB;EACpBA,UAAA,CAAAA,UAAA,0CAAc;EACdA,UAAA,CAAAA,UAAA,0CAAc;AAChB,CAAC,EARWA,UAAU,KAAVA,UAAU;AAUtB,OAAO,IAAMC,gBAAgB,GAAGC,MAAM,CAACC,MAAM,CAACH,UAAU,CAAC;AAEzD;AACA,WAAYI,cAIX;AAJD,WAAYA,cAAc;EACxBA,cAAA,CAAAA,cAAA,oBAAG;EACHA,cAAA,CAAAA,cAAA,kCAAU;EACVA,cAAA,CAAAA,cAAA,gCAAS;AACX,CAAC,EAJWA,cAAc,KAAdA,cAAc","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}