{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar _a;\nimport { SpanKind } from '@opentelemetry/api';\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unused-vars */\nexport var opentelemetryProto;\n(function (opentelemetryProto) {\n  var metrics;\n  (function (metrics) {\n    var v1;\n    (function (v1) {\n      var AggregationTemporality;\n      (function (AggregationTemporality) {\n        // UNSPECIFIED is the default AggregationTemporality, it MUST not be used.\n        AggregationTemporality[AggregationTemporality[\"AGGREGATION_TEMPORALITY_UNSPECIFIED\"] = 0] = \"AGGREGATION_TEMPORALITY_UNSPECIFIED\";\n        // DELTA is an AggregationTemporality for a metric aggregator which reports\n        // changes since last report time. Successive metrics contain aggregation of\n        // values from continuous and non-overlapping intervals.\n        //\n        // The values for a DELTA metric are based only on the time interval\n        // associated with one measurement cycle. There is no dependency on\n        // previous measurements like is the case for CUMULATIVE metrics.\n        //\n        // For example, consider a system measuring the number of requests that\n        // it receives and reports the sum of these requests every second as a\n        // DELTA metric:\n        //\n        //   1. The system starts receiving at time=t_0.\n        //   2. A request is received, the system measures 1 request.\n        //   3. A request is received, the system measures 1 request.\n        //   4. A request is received, the system measures 1 request.\n        //   5. The 1 second collection cycle ends. A metric is exported for the\n        //      number of requests received over the interval of time t_0 to\n        //      t_0+1 with a value of 3.\n        //   6. A request is received, the system measures 1 request.\n        //   7. A request is received, the system measures 1 request.\n        //   8. The 1 second collection cycle ends. A metric is exported for the\n        //      number of requests received over the interval of time t_0+1 to\n        //      t_0+2 with a value of 2.\n        AggregationTemporality[AggregationTemporality[\"AGGREGATION_TEMPORALITY_DELTA\"] = 1] = \"AGGREGATION_TEMPORALITY_DELTA\";\n        // CUMULATIVE is an AggregationTemporality for a metric aggregator which\n        // reports changes since a fixed start time. This means that current values\n        // of a CUMULATIVE metric depend on all previous measurements since the\n        // start time. Because of this, the sender is required to retain this state\n        // in some form. If this state is lost or invalidated, the CUMULATIVE metric\n        // values MUST be reset and a new fixed start time following the last\n        // reported measurement time sent MUST be used.\n        //\n        // For example, consider a system measuring the number of requests that\n        // it receives and reports the sum of these requests every second as a\n        // CUMULATIVE metric:\n        //\n        //   1. The system starts receiving at time=t_0.\n        //   2. A request is received, the system measures 1 request.\n        //   3. A request is received, the system measures 1 request.\n        //   4. A request is received, the system measures 1 request.\n        //   5. The 1 second collection cycle ends. A metric is exported for the\n        //      number of requests received over the interval of time t_0 to\n        //      t_0+1 with a value of 3.\n        //   6. A request is received, the system measures 1 request.\n        //   7. A request is received, the system measures 1 request.\n        //   8. The 1 second collection cycle ends. A metric is exported for the\n        //      number of requests received over the interval of time t_0 to\n        //      t_0+2 with a value of 5.\n        //   9. The system experiences a fault and loses state.\n        //   10. The system recovers and resumes receiving at time=t_1.\n        //   11. A request is received, the system measures 1 request.\n        //   12. The 1 second collection cycle ends. A metric is exported for the\n        //      number of requests received over the interval of time t_1 to\n        //      t_0+1 with a value of 1.\n        //\n        // Note: Even though, when reporting changes since last report time, using\n        // CUMULATIVE is valid, it is not recommended. This may cause problems for\n        // systems that do not use start_time to determine when the aggregation\n        // value was reset (e.g. Prometheus).\n        AggregationTemporality[AggregationTemporality[\"AGGREGATION_TEMPORALITY_CUMULATIVE\"] = 2] = \"AGGREGATION_TEMPORALITY_CUMULATIVE\";\n      })(AggregationTemporality = v1.AggregationTemporality || (v1.AggregationTemporality = {}));\n    })(v1 = metrics.v1 || (metrics.v1 = {}));\n  })(metrics = opentelemetryProto.metrics || (opentelemetryProto.metrics = {}));\n  var trace;\n  (function (trace) {\n    var v1;\n    (function (v1) {\n      var ConstantSampler;\n      (function (ConstantSampler) {\n        var ConstantDecision;\n        (function (ConstantDecision) {\n          ConstantDecision[ConstantDecision[\"ALWAYS_OFF\"] = 0] = \"ALWAYS_OFF\";\n          ConstantDecision[ConstantDecision[\"ALWAYS_ON\"] = 1] = \"ALWAYS_ON\";\n          ConstantDecision[ConstantDecision[\"ALWAYS_PARENT\"] = 2] = \"ALWAYS_PARENT\";\n        })(ConstantDecision = ConstantSampler.ConstantDecision || (ConstantSampler.ConstantDecision = {}));\n      })(ConstantSampler = v1.ConstantSampler || (v1.ConstantSampler = {}));\n      var Span;\n      (function (Span) {\n        // eslint-disable-next-line @typescript-eslint/no-shadow\n        var SpanKind;\n        (function (SpanKind) {\n          SpanKind[SpanKind[\"SPAN_KIND_UNSPECIFIED\"] = 0] = \"SPAN_KIND_UNSPECIFIED\";\n          SpanKind[SpanKind[\"SPAN_KIND_INTERNAL\"] = 1] = \"SPAN_KIND_INTERNAL\";\n          SpanKind[SpanKind[\"SPAN_KIND_SERVER\"] = 2] = \"SPAN_KIND_SERVER\";\n          SpanKind[SpanKind[\"SPAN_KIND_CLIENT\"] = 3] = \"SPAN_KIND_CLIENT\";\n          SpanKind[SpanKind[\"SPAN_KIND_PRODUCER\"] = 4] = \"SPAN_KIND_PRODUCER\";\n          SpanKind[SpanKind[\"SPAN_KIND_CONSUMER\"] = 5] = \"SPAN_KIND_CONSUMER\";\n        })(SpanKind = Span.SpanKind || (Span.SpanKind = {}));\n      })(Span = v1.Span || (v1.Span = {}));\n    })(v1 = trace.v1 || (trace.v1 = {}));\n  })(trace = opentelemetryProto.trace || (opentelemetryProto.trace = {}));\n  var common;\n  (function (common) {\n    var v1;\n    (function (v1) {\n      var ValueType;\n      (function (ValueType) {\n        ValueType[ValueType[\"STRING\"] = 0] = \"STRING\";\n        ValueType[ValueType[\"INT\"] = 1] = \"INT\";\n        ValueType[ValueType[\"DOUBLE\"] = 2] = \"DOUBLE\";\n        ValueType[ValueType[\"BOOL\"] = 3] = \"BOOL\";\n      })(ValueType = v1.ValueType || (v1.ValueType = {}));\n    })(v1 = common.v1 || (common.v1 = {}));\n  })(common = opentelemetryProto.common || (opentelemetryProto.common = {}));\n})(opentelemetryProto || (opentelemetryProto = {}));\n/**\n * Interface for handling error\n */\nvar OTLPExporterError = /** @class */function (_super) {\n  __extends(OTLPExporterError, _super);\n  function OTLPExporterError(message, code, data) {\n    var _this = _super.call(this, message) || this;\n    _this.name = 'OTLPExporterError';\n    _this.data = data;\n    _this.code = code;\n    return _this;\n  }\n  return OTLPExporterError;\n}(Error);\nexport { OTLPExporterError };\n/**\n * Mapping between api SpanKind and proto SpanKind\n */\nexport var OTLP_SPAN_KIND_MAPPING = (_a = {}, _a[SpanKind.INTERNAL] = opentelemetryProto.trace.v1.Span.SpanKind.SPAN_KIND_INTERNAL, _a[SpanKind.SERVER] = opentelemetryProto.trace.v1.Span.SpanKind.SPAN_KIND_SERVER, _a[SpanKind.CLIENT] = opentelemetryProto.trace.v1.Span.SpanKind.SPAN_KIND_CLIENT, _a[SpanKind.PRODUCER] = opentelemetryProto.trace.v1.Span.SpanKind.SPAN_KIND_PRODUCER, _a[SpanKind.CONSUMER] = opentelemetryProto.trace.v1.Span.SpanKind.SPAN_KIND_CONSUMER, _a);","map":{"version":3,"names":["SpanKind","opentelemetryProto","metrics","v1","AggregationTemporality","trace","ConstantSampler","ConstantDecision","Span","common","ValueType","OTLPExporterError","_super","__extends","message","code","data","_this","call","name","Error","OTLP_SPAN_KIND_MAPPING","_a","INTERNAL","SPAN_KIND_INTERNAL","SERVER","SPAN_KIND_SERVER","CLIENT","SPAN_KIND_CLIENT","PRODUCER","SPAN_KIND_PRODUCER","CONSUMER","SPAN_KIND_CONSUMER"],"sources":["C:\\Users\\Sartaj\\Desktop\\ObservaCart\\observacart\\frontend\\node_modules\\@opentelemetry\\exporter-otlp-http\\src\\types.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { SpanAttributes, SpanKind, SpanStatusCode } from '@opentelemetry/api';\n\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\nexport namespace opentelemetryProto {\n  export namespace collector {\n    export namespace trace.v1 {\n      export interface TraceService {\n        service: opentelemetryProto.collector.trace.v1.TraceService;\n      }\n\n      export interface ExportTraceServiceRequest {\n        resourceSpans: opentelemetryProto.trace.v1.ResourceSpans[];\n      }\n    }\n    export namespace metrics.v1 {\n      export interface ExportMetricsServiceRequest {\n        resourceMetrics: opentelemetryProto.metrics.v1.ResourceMetrics[];\n      }\n    }\n  }\n\n  export namespace resource.v1 {\n    export interface Resource {\n      attributes: opentelemetryProto.common.v1.KeyValue[];\n      droppedAttributesCount: number;\n    }\n  }\n\n  export namespace metrics.v1 {\n    export interface Metric {\n      name: string;\n      description: string;\n      unit: string;\n      // data:\n      intGauge?: opentelemetryProto.metrics.v1.Gauge;\n      doubleGauge?: opentelemetryProto.metrics.v1.Gauge;\n      intSum?: opentelemetryProto.metrics.v1.Sum;\n      doubleSum?: opentelemetryProto.metrics.v1.Sum;\n      intHistogram?: opentelemetryProto.metrics.v1.Histogram;\n      doubleHistogram?: opentelemetryProto.metrics.v1.Histogram;\n    }\n\n    export interface Gauge {\n      dataPoints: opentelemetryProto.metrics.v1.DataPoint[];\n    }\n\n    export interface Sum {\n      dataPoints: opentelemetryProto.metrics.v1.DataPoint[];\n      aggregationTemporality: opentelemetryProto.metrics.v1.AggregationTemporality;\n      isMonotonic: boolean;\n    }\n\n    export interface Histogram {\n      dataPoints: opentelemetryProto.metrics.v1.HistogramDataPoint[];\n      aggregationTemporality: opentelemetryProto.metrics.v1.AggregationTemporality;\n    }\n\n    export interface DataPoint {\n      labels: opentelemetryProto.common.v1.StringKeyValue[];\n      startTimeUnixNano: number;\n      timeUnixNano: number;\n      value: number;\n      exemplars?: opentelemetryProto.metrics.v1.Exemplar[];\n    }\n\n    export interface Exemplar {\n      filteredLabels: opentelemetryProto.common.v1.StringKeyValue[];\n      timeUnixNano: number;\n      value: number;\n      spanId: Uint8Array;\n      traceId: Uint8Array;\n    }\n\n    export interface HistogramDataPoint {\n      labels: opentelemetryProto.common.v1.StringKeyValue[];\n      startTimeUnixNano: number;\n      timeUnixNano: number;\n      count: number;\n      sum: number;\n      bucketCounts?: number[];\n      explicitBounds?: number[];\n      exemplars?: opentelemetryProto.metrics.v1.Exemplar[][];\n    }\n\n    export interface InstrumentationLibraryMetrics {\n      instrumentationLibrary?: opentelemetryProto.common.v1.InstrumentationLibrary;\n      metrics: opentelemetryProto.metrics.v1.Metric[];\n    }\n\n    export interface ResourceMetrics {\n      resource?: opentelemetryProto.resource.v1.Resource;\n      instrumentationLibraryMetrics: opentelemetryProto.metrics.v1.InstrumentationLibraryMetrics[];\n    }\n\n    export enum AggregationTemporality {\n      // UNSPECIFIED is the default AggregationTemporality, it MUST not be used.\n      AGGREGATION_TEMPORALITY_UNSPECIFIED = 0,\n\n      // DELTA is an AggregationTemporality for a metric aggregator which reports\n      // changes since last report time. Successive metrics contain aggregation of\n      // values from continuous and non-overlapping intervals.\n      //\n      // The values for a DELTA metric are based only on the time interval\n      // associated with one measurement cycle. There is no dependency on\n      // previous measurements like is the case for CUMULATIVE metrics.\n      //\n      // For example, consider a system measuring the number of requests that\n      // it receives and reports the sum of these requests every second as a\n      // DELTA metric:\n      //\n      //   1. The system starts receiving at time=t_0.\n      //   2. A request is received, the system measures 1 request.\n      //   3. A request is received, the system measures 1 request.\n      //   4. A request is received, the system measures 1 request.\n      //   5. The 1 second collection cycle ends. A metric is exported for the\n      //      number of requests received over the interval of time t_0 to\n      //      t_0+1 with a value of 3.\n      //   6. A request is received, the system measures 1 request.\n      //   7. A request is received, the system measures 1 request.\n      //   8. The 1 second collection cycle ends. A metric is exported for the\n      //      number of requests received over the interval of time t_0+1 to\n      //      t_0+2 with a value of 2.\n      AGGREGATION_TEMPORALITY_DELTA = 1,\n\n      // CUMULATIVE is an AggregationTemporality for a metric aggregator which\n      // reports changes since a fixed start time. This means that current values\n      // of a CUMULATIVE metric depend on all previous measurements since the\n      // start time. Because of this, the sender is required to retain this state\n      // in some form. If this state is lost or invalidated, the CUMULATIVE metric\n      // values MUST be reset and a new fixed start time following the last\n      // reported measurement time sent MUST be used.\n      //\n      // For example, consider a system measuring the number of requests that\n      // it receives and reports the sum of these requests every second as a\n      // CUMULATIVE metric:\n      //\n      //   1. The system starts receiving at time=t_0.\n      //   2. A request is received, the system measures 1 request.\n      //   3. A request is received, the system measures 1 request.\n      //   4. A request is received, the system measures 1 request.\n      //   5. The 1 second collection cycle ends. A metric is exported for the\n      //      number of requests received over the interval of time t_0 to\n      //      t_0+1 with a value of 3.\n      //   6. A request is received, the system measures 1 request.\n      //   7. A request is received, the system measures 1 request.\n      //   8. The 1 second collection cycle ends. A metric is exported for the\n      //      number of requests received over the interval of time t_0 to\n      //      t_0+2 with a value of 5.\n      //   9. The system experiences a fault and loses state.\n      //   10. The system recovers and resumes receiving at time=t_1.\n      //   11. A request is received, the system measures 1 request.\n      //   12. The 1 second collection cycle ends. A metric is exported for the\n      //      number of requests received over the interval of time t_1 to\n      //      t_0+1 with a value of 1.\n      //\n      // Note: Even though, when reporting changes since last report time, using\n      // CUMULATIVE is valid, it is not recommended. This may cause problems for\n      // systems that do not use start_time to determine when the aggregation\n      // value was reset (e.g. Prometheus).\n      AGGREGATION_TEMPORALITY_CUMULATIVE = 2,\n    }\n  }\n\n  export namespace trace.v1 {\n    export namespace ConstantSampler {\n      export enum ConstantDecision {\n        ALWAYS_OFF = 0,\n        ALWAYS_ON = 1,\n        ALWAYS_PARENT = 2,\n      }\n    }\n    export namespace Span {\n      export interface Event {\n        timeUnixNano: number;\n        name: string;\n        attributes?: opentelemetryProto.common.v1.KeyValue[];\n        droppedAttributesCount: number;\n      }\n\n      export interface Link {\n        traceId: string;\n        spanId: string;\n        traceState?: opentelemetryProto.trace.v1.Span.TraceState;\n        attributes?: opentelemetryProto.common.v1.KeyValue[];\n        droppedAttributesCount: number;\n      }\n\n      // eslint-disable-next-line @typescript-eslint/no-shadow\n      export enum SpanKind {\n        SPAN_KIND_UNSPECIFIED,\n        SPAN_KIND_INTERNAL,\n        SPAN_KIND_SERVER,\n        SPAN_KIND_CLIENT,\n        SPAN_KIND_PRODUCER,\n        SPAN_KIND_CONSUMER,\n      }\n\n      export type TraceState = string | undefined;\n    }\n\n    export interface ConstantSampler {\n      decision?: opentelemetryProto.trace.v1.ConstantSampler.ConstantDecision;\n    }\n\n    export interface InstrumentationLibrarySpans {\n      instrumentationLibrary?: opentelemetryProto.common.v1.InstrumentationLibrary;\n      spans: opentelemetryProto.trace.v1.Span[];\n    }\n\n    export interface ProbabilitySampler {\n      samplingProbability?: number | null;\n    }\n\n    export interface RateLimitingSampler {\n      qps?: number | null;\n    }\n\n    export interface ResourceSpans {\n      resource?: opentelemetryProto.resource.v1.Resource;\n      instrumentationLibrarySpans: opentelemetryProto.trace.v1.InstrumentationLibrarySpans[];\n    }\n\n    export interface Span {\n      traceId: string;\n      spanId: string;\n      traceState: opentelemetryProto.trace.v1.Span.TraceState;\n      parentSpanId?: string;\n      name?: string;\n      kind?: opentelemetryProto.trace.v1.Span.SpanKind;\n      startTimeUnixNano?: number;\n      endTimeUnixNano?: number;\n      attributes?: opentelemetryProto.common.v1.KeyValue[];\n      droppedAttributesCount: number;\n      events?: opentelemetryProto.trace.v1.Span.Event[];\n      droppedEventsCount: number;\n      links?: opentelemetryProto.trace.v1.Span.Link[];\n      droppedLinksCount: number;\n      status?: SpanStatus;\n    }\n\n    export interface SpanStatus {\n      /** The status code of this message. */\n      code: SpanStatusCode;\n      /** A developer-facing error message. */\n      message?: string;\n    }\n\n    export interface TraceConfig {\n      constantSampler?: ConstantSampler | null;\n      probabilitySampler?: ProbabilitySampler | null;\n      rateLimitingSampler?: RateLimitingSampler | null;\n    }\n  }\n  export namespace common.v1 {\n    export interface KeyValue {\n      key: string;\n      value: AnyValue;\n    }\n\n    export type ArrayValue = {\n      values: AnyValue[];\n    };\n\n    export interface KeyValueList {\n      values: KeyValue[];\n    }\n\n    export type AnyValue = {\n      stringValue?: string;\n      boolValue?: boolean;\n      intValue?: number;\n      doubleValue?: number;\n      arrayValue?: ArrayValue;\n      kvlistValue?: KeyValueList;\n    };\n\n    export interface InstrumentationLibrary {\n      name: string;\n      version?: string;\n    }\n\n    export interface StringKeyValue {\n      key: string;\n      value: string;\n    }\n\n    export enum ValueType {\n      STRING,\n      INT,\n      DOUBLE,\n      BOOL,\n    }\n  }\n}\n\n/**\n * Interface for handling error\n */\nexport class OTLPExporterError extends Error {\n  readonly code?: number;\n  override readonly name: string = 'OTLPExporterError';\n  readonly data?: string;\n\n  constructor(message?: string, code?: number, data?: string) {\n    super(message);\n    this.data = data;\n    this.code = code;\n  }\n}\n\n/**\n * Interface for handling export service errors\n */\nexport interface ExportServiceError {\n  name: string;\n  code: number;\n  details: string;\n  metadata: { [key: string]: unknown };\n  message: string;\n  stack: string;\n}\n\n/**\n * Collector Exporter base config\n */\nexport interface OTLPExporterConfigBase {\n  headers?: Partial<Record<string, unknown>>;\n  hostname?: string;\n  attributes?: SpanAttributes;\n  url?: string;\n  concurrencyLimit?: number;\n}\n\n/**\n * Mapping between api SpanKind and proto SpanKind\n */\nexport const OTLP_SPAN_KIND_MAPPING = {\n  [SpanKind.INTERNAL]:\n    opentelemetryProto.trace.v1.Span.SpanKind.SPAN_KIND_INTERNAL,\n  [SpanKind.SERVER]: opentelemetryProto.trace.v1.Span.SpanKind.SPAN_KIND_SERVER,\n  [SpanKind.CLIENT]: opentelemetryProto.trace.v1.Span.SpanKind.SPAN_KIND_CLIENT,\n  [SpanKind.PRODUCER]:\n    opentelemetryProto.trace.v1.Span.SpanKind.SPAN_KIND_PRODUCER,\n  [SpanKind.CONSUMER]:\n    opentelemetryProto.trace.v1.Span.SpanKind.SPAN_KIND_CONSUMER,\n};\n"],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgBA,SAAyBA,QAAQ,QAAwB,oBAAoB;AAE7E;AACA;AAEA,OAAM,IAAWC,kBAAkB;AAAnC,WAAiBA,kBAAkB;EAyBjC,IAAiBC,OAAO;EAAxB,WAAiBA,OAAO;IAAC,IAAAC,EAAE;IAAF,WAAAA,EAAE;MAkEzB,IAAYC,sBAkEX;MAlED,WAAYA,sBAAsB;QAChC;QACAA,sBAAA,CAAAA,sBAAA,oFAAuC;QAEvC;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACAA,sBAAA,CAAAA,sBAAA,wEAAiC;QAEjC;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACAA,sBAAA,CAAAA,sBAAA,kFAAsC;MACxC,CAAC,EAlEWA,sBAAsB,GAAtBD,EAAA,CAAAC,sBAAsB,KAAtBD,EAAA,CAAAC,sBAAsB;IAmEpC,CAAC,EArIwBD,EAAE,GAAFD,OAAA,CAAAC,EAAE,KAAFD,OAAA,CAAAC,EAAE;EAqI3B,CAAC,EArIgBD,OAAO,GAAPD,kBAAA,CAAAC,OAAO,KAAPD,kBAAA,CAAAC,OAAO;EAuIxB,IAAiBG,KAAK;EAAtB,WAAiBA,KAAK;IAAC,IAAAF,EAAE;IAAF,WAAAA,EAAE;MACvB,IAAiBG,eAAe;MAAhC,WAAiBA,eAAe;QAC9B,IAAYC,gBAIX;QAJD,WAAYA,gBAAgB;UAC1BA,gBAAA,CAAAA,gBAAA,kCAAc;UACdA,gBAAA,CAAAA,gBAAA,gCAAa;UACbA,gBAAA,CAAAA,gBAAA,wCAAiB;QACnB,CAAC,EAJWA,gBAAgB,GAAhBD,eAAA,CAAAC,gBAAgB,KAAhBD,eAAA,CAAAC,gBAAgB;MAK9B,CAAC,EANgBD,eAAe,GAAfH,EAAA,CAAAG,eAAe,KAAfH,EAAA,CAAAG,eAAe;MAOhC,IAAiBE,IAAI;MAArB,WAAiBA,IAAI;QAgBnB;QACA,IAAYR,QAOX;QAPD,WAAYA,QAAQ;UAClBA,QAAA,CAAAA,QAAA,wDAAqB;UACrBA,QAAA,CAAAA,QAAA,kDAAkB;UAClBA,QAAA,CAAAA,QAAA,8CAAgB;UAChBA,QAAA,CAAAA,QAAA,8CAAgB;UAChBA,QAAA,CAAAA,QAAA,kDAAkB;UAClBA,QAAA,CAAAA,QAAA,kDAAkB;QACpB,CAAC,EAPWA,QAAQ,GAARQ,IAAA,CAAAR,QAAQ,KAARQ,IAAA,CAAAR,QAAQ;MAUtB,CAAC,EA3BgBQ,IAAI,GAAJL,EAAA,CAAAK,IAAI,KAAJL,EAAA,CAAAK,IAAI;IAiFvB,CAAC,EAzFsBL,EAAE,GAAFE,KAAA,CAAAF,EAAE,KAAFE,KAAA,CAAAF,EAAE;EAyFzB,CAAC,EAzFgBE,KAAK,GAALJ,kBAAA,CAAAI,KAAK,KAALJ,kBAAA,CAAAI,KAAK;EA0FtB,IAAiBI,MAAM;EAAvB,WAAiBA,MAAM;IAAC,IAAAN,EAAE;IAAF,WAAAA,EAAE;MAiCxB,IAAYO,SAKX;MALD,WAAYA,SAAS;QACnBA,SAAA,CAAAA,SAAA,0BAAM;QACNA,SAAA,CAAAA,SAAA,oBAAG;QACHA,SAAA,CAAAA,SAAA,0BAAM;QACNA,SAAA,CAAAA,SAAA,sBAAI;MACN,CAAC,EALWA,SAAS,GAATP,EAAA,CAAAO,SAAS,KAATP,EAAA,CAAAO,SAAS;IAMvB,CAAC,EAvCuBP,EAAE,GAAFM,MAAA,CAAAN,EAAE,KAAFM,MAAA,CAAAN,EAAE;EAuC1B,CAAC,EAvCgBM,MAAM,GAANR,kBAAA,CAAAQ,MAAM,KAANR,kBAAA,CAAAQ,MAAM;AAwCzB,CAAC,EAlSgBR,kBAAkB,KAAlBA,kBAAkB;AAoSnC;;;AAGA,IAAAU,iBAAA,0BAAAC,MAAA;EAAuCC,SAAA,CAAAF,iBAAA,EAAAC,MAAA;EAKrC,SAAAD,kBAAYG,OAAgB,EAAEC,IAAa,EAAEC,IAAa;IAA1D,IAAAC,KAAA,GACEL,MAAA,CAAAM,IAAA,OAAMJ,OAAO,CAAC;IAJEG,KAAA,CAAAE,IAAI,GAAW,mBAAmB;IAKlDF,KAAI,CAACD,IAAI,GAAGA,IAAI;IAChBC,KAAI,CAACF,IAAI,GAAGA,IAAI;;EAClB;EACF,OAAAJ,iBAAC;AAAD,CAAC,CAVsCS,KAAK;;AAmC5C;;;AAGA,OAAO,IAAMC,sBAAsB,IAAAC,EAAA,OACjCA,EAAA,CAACtB,QAAQ,CAACuB,QAAQ,IAChBtB,kBAAkB,CAACI,KAAK,CAACF,EAAE,CAACK,IAAI,CAACR,QAAQ,CAACwB,kBAAkB,EAC9DF,EAAA,CAACtB,QAAQ,CAACyB,MAAM,IAAGxB,kBAAkB,CAACI,KAAK,CAACF,EAAE,CAACK,IAAI,CAACR,QAAQ,CAAC0B,gBAAgB,EAC7EJ,EAAA,CAACtB,QAAQ,CAAC2B,MAAM,IAAG1B,kBAAkB,CAACI,KAAK,CAACF,EAAE,CAACK,IAAI,CAACR,QAAQ,CAAC4B,gBAAgB,EAC7EN,EAAA,CAACtB,QAAQ,CAAC6B,QAAQ,IAChB5B,kBAAkB,CAACI,KAAK,CAACF,EAAE,CAACK,IAAI,CAACR,QAAQ,CAAC8B,kBAAkB,EAC9DR,EAAA,CAACtB,QAAQ,CAAC+B,QAAQ,IAChB9B,kBAAkB,CAACI,KAAK,CAACF,EAAE,CAACK,IAAI,CAACR,QAAQ,CAACgC,kBAAkB,E,GAC/D","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}