{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { AggregatorKind } from '../types';\nimport { hrTime } from '@opentelemetry/core';\n/**\n * Basic aggregator which observes events and counts them in pre-defined buckets\n * and provides the total sum and count of all observations.\n */\nvar HistogramAggregator = /** @class */function () {\n  function HistogramAggregator(boundaries) {\n    this.kind = AggregatorKind.HISTOGRAM;\n    if (boundaries === undefined || boundaries.length === 0) {\n      throw new Error('HistogramAggregator should be created with boundaries.');\n    }\n    // we need to an ordered set to be able to correctly compute count for each\n    // boundary since we'll iterate on each in order.\n    this._boundaries = boundaries.sort(function (a, b) {\n      return a - b;\n    });\n    this._current = this._newEmptyCheckpoint();\n    this._lastUpdateTime = hrTime();\n  }\n  HistogramAggregator.prototype.update = function (value) {\n    this._lastUpdateTime = hrTime();\n    this._current.count += 1;\n    this._current.sum += value;\n    for (var i = 0; i < this._boundaries.length; i++) {\n      if (value < this._boundaries[i]) {\n        this._current.buckets.counts[i] += 1;\n        return;\n      }\n    }\n    // value is above all observed boundaries\n    this._current.buckets.counts[this._boundaries.length] += 1;\n  };\n  HistogramAggregator.prototype.toPoint = function () {\n    return {\n      value: this._current,\n      timestamp: this._lastUpdateTime\n    };\n  };\n  HistogramAggregator.prototype._newEmptyCheckpoint = function () {\n    return {\n      buckets: {\n        boundaries: this._boundaries,\n        counts: this._boundaries.map(function () {\n          return 0;\n        }).concat([0])\n      },\n      sum: 0,\n      count: 0\n    };\n  };\n  return HistogramAggregator;\n}();\nexport { HistogramAggregator };","map":{"version":3,"names":["AggregatorKind","hrTime","HistogramAggregator","boundaries","kind","HISTOGRAM","undefined","length","Error","_boundaries","sort","a","b","_current","_newEmptyCheckpoint","_lastUpdateTime","prototype","update","value","count","sum","i","buckets","counts","toPoint","timestamp","map","concat"],"sources":["C:\\Users\\Sartaj\\Desktop\\ObservaCart\\observacart\\frontend\\node_modules\\@opentelemetry\\sdk-metrics-base\\src\\export\\aggregators\\Histogram.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  HistogramAggregatorType,\n  Point,\n  Histogram,\n  AggregatorKind,\n} from '../types';\nimport { HrTime } from '@opentelemetry/api';\nimport { hrTime } from '@opentelemetry/core';\n\n/**\n * Basic aggregator which observes events and counts them in pre-defined buckets\n * and provides the total sum and count of all observations.\n */\nexport class HistogramAggregator implements HistogramAggregatorType {\n  public kind: AggregatorKind.HISTOGRAM = AggregatorKind.HISTOGRAM;\n  private _current: Histogram;\n  private _lastUpdateTime: HrTime;\n  private readonly _boundaries: number[];\n\n  constructor(boundaries: number[]) {\n    if (boundaries === undefined || boundaries.length === 0) {\n      throw new Error('HistogramAggregator should be created with boundaries.');\n    }\n    // we need to an ordered set to be able to correctly compute count for each\n    // boundary since we'll iterate on each in order.\n    this._boundaries = boundaries.sort((a, b) => a - b);\n    this._current = this._newEmptyCheckpoint();\n    this._lastUpdateTime = hrTime();\n  }\n\n  update(value: number): void {\n    this._lastUpdateTime = hrTime();\n    this._current.count += 1;\n    this._current.sum += value;\n\n    for (let i = 0; i < this._boundaries.length; i++) {\n      if (value < this._boundaries[i]) {\n        this._current.buckets.counts[i] += 1;\n        return;\n      }\n    }\n    // value is above all observed boundaries\n    this._current.buckets.counts[this._boundaries.length] += 1;\n  }\n\n  toPoint(): Point<Histogram> {\n    return {\n      value: this._current,\n      timestamp: this._lastUpdateTime,\n    };\n  }\n\n  private _newEmptyCheckpoint(): Histogram {\n    return {\n      buckets: {\n        boundaries: this._boundaries,\n        counts: this._boundaries.map(() => 0).concat([0]),\n      },\n      sum: 0,\n      count: 0,\n    };\n  }\n}\n"],"mappings":"AAAA;;;;;;;;;;;;;;;AAgBA,SAIEA,cAAc,QACT,UAAU;AAEjB,SAASC,MAAM,QAAQ,qBAAqB;AAE5C;;;;AAIA,IAAAC,mBAAA;EAME,SAAAA,oBAAYC,UAAoB;IALzB,KAAAC,IAAI,GAA6BJ,cAAc,CAACK,SAAS;IAM9D,IAAIF,UAAU,KAAKG,SAAS,IAAIH,UAAU,CAACI,MAAM,KAAK,CAAC,EAAE;MACvD,MAAM,IAAIC,KAAK,CAAC,wDAAwD,CAAC;;IAE3E;IACA;IACA,IAAI,CAACC,WAAW,GAAGN,UAAU,CAACO,IAAI,CAAC,UAACC,CAAC,EAAEC,CAAC;MAAK,OAAAD,CAAC,GAAGC,CAAC;IAAL,CAAK,CAAC;IACnD,IAAI,CAACC,QAAQ,GAAG,IAAI,CAACC,mBAAmB,EAAE;IAC1C,IAAI,CAACC,eAAe,GAAGd,MAAM,EAAE;EACjC;EAEAC,mBAAA,CAAAc,SAAA,CAAAC,MAAM,GAAN,UAAOC,KAAa;IAClB,IAAI,CAACH,eAAe,GAAGd,MAAM,EAAE;IAC/B,IAAI,CAACY,QAAQ,CAACM,KAAK,IAAI,CAAC;IACxB,IAAI,CAACN,QAAQ,CAACO,GAAG,IAAIF,KAAK;IAE1B,KAAK,IAAIG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACZ,WAAW,CAACF,MAAM,EAAEc,CAAC,EAAE,EAAE;MAChD,IAAIH,KAAK,GAAG,IAAI,CAACT,WAAW,CAACY,CAAC,CAAC,EAAE;QAC/B,IAAI,CAACR,QAAQ,CAACS,OAAO,CAACC,MAAM,CAACF,CAAC,CAAC,IAAI,CAAC;QACpC;;;IAGJ;IACA,IAAI,CAACR,QAAQ,CAACS,OAAO,CAACC,MAAM,CAAC,IAAI,CAACd,WAAW,CAACF,MAAM,CAAC,IAAI,CAAC;EAC5D,CAAC;EAEDL,mBAAA,CAAAc,SAAA,CAAAQ,OAAO,GAAP;IACE,OAAO;MACLN,KAAK,EAAE,IAAI,CAACL,QAAQ;MACpBY,SAAS,EAAE,IAAI,CAACV;KACjB;EACH,CAAC;EAEOb,mBAAA,CAAAc,SAAA,CAAAF,mBAAmB,GAA3B;IACE,OAAO;MACLQ,OAAO,EAAE;QACPnB,UAAU,EAAE,IAAI,CAACM,WAAW;QAC5Bc,MAAM,EAAE,IAAI,CAACd,WAAW,CAACiB,GAAG,CAAC;UAAM,QAAC;QAAD,CAAC,CAAC,CAACC,MAAM,CAAC,CAAC,CAAC,CAAC;OACjD;MACDP,GAAG,EAAE,CAAC;MACND,KAAK,EAAE;KACR;EACH,CAAC;EACH,OAAAjB,mBAAC;AAAD,CAAC,CAjDD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}