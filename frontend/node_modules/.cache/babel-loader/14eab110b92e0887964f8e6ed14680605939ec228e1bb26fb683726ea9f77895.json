{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nimport * as aggregators from './aggregators';\nimport { MetricKind } from './types';\n/**\n * Base class for all processor types.\n *\n * The processor is responsible for storing the aggregators and aggregated\n * values received from updates from metrics in the meter. The stored values\n * will be sent to an exporter for exporting.\n */\nvar Processor = /** @class */function () {\n  function Processor() {\n    this._batchMap = new Map();\n  }\n  Processor.prototype.checkPointSet = function () {\n    return Array.from(this._batchMap.values());\n  };\n  return Processor;\n}();\nexport { Processor };\n/**\n * Processor which retains all dimensions/labels. It accepts all records and\n * passes them for exporting.\n */\nvar UngroupedProcessor = /** @class */function (_super) {\n  __extends(UngroupedProcessor, _super);\n  function UngroupedProcessor() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  UngroupedProcessor.prototype.aggregatorFor = function (metricDescriptor) {\n    switch (metricDescriptor.metricKind) {\n      case MetricKind.COUNTER:\n      case MetricKind.UP_DOWN_COUNTER:\n        return new aggregators.SumAggregator();\n      case MetricKind.SUM_OBSERVER:\n      case MetricKind.UP_DOWN_SUM_OBSERVER:\n      case MetricKind.VALUE_OBSERVER:\n        return new aggregators.LastValueAggregator();\n      case MetricKind.VALUE_RECORDER:\n        return new aggregators.HistogramAggregator(metricDescriptor.boundaries || [Infinity]);\n      default:\n        return new aggregators.LastValueAggregator();\n    }\n  };\n  UngroupedProcessor.prototype.process = function (record) {\n    var labels = Object.keys(record.labels).map(function (k) {\n      return k + \"=\" + record.labels[k];\n    }).join(',');\n    this._batchMap.set(record.descriptor.name + labels, record);\n  };\n  return UngroupedProcessor;\n}(Processor);\nexport { UngroupedProcessor };","map":{"version":3,"names":["aggregators","MetricKind","Processor","_batchMap","Map","prototype","checkPointSet","Array","from","values","UngroupedProcessor","_super","__extends","aggregatorFor","metricDescriptor","metricKind","COUNTER","UP_DOWN_COUNTER","SumAggregator","SUM_OBSERVER","UP_DOWN_SUM_OBSERVER","VALUE_OBSERVER","LastValueAggregator","VALUE_RECORDER","HistogramAggregator","boundaries","Infinity","process","record","labels","Object","keys","map","k","join","set","descriptor","name"],"sources":["C:\\Users\\Sartaj\\Desktop\\ObservaCart\\observacart\\frontend\\node_modules\\@opentelemetry\\sdk-metrics-base\\src\\export\\Processor.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as aggregators from './aggregators';\nimport {\n  MetricRecord,\n  MetricKind,\n  Aggregator,\n  MetricDescriptor,\n} from './types';\n\n/**\n * Base class for all processor types.\n *\n * The processor is responsible for storing the aggregators and aggregated\n * values received from updates from metrics in the meter. The stored values\n * will be sent to an exporter for exporting.\n */\nexport abstract class Processor {\n  protected readonly _batchMap = new Map<string, MetricRecord>();\n\n  /** Returns an aggregator based off metric descriptor. */\n  abstract aggregatorFor(metricKind: MetricDescriptor): Aggregator;\n\n  /** Stores record information to be ready for exporting. */\n  abstract process(record: MetricRecord): void;\n\n  checkPointSet(): MetricRecord[] {\n    return Array.from(this._batchMap.values());\n  }\n}\n\n/**\n * Processor which retains all dimensions/labels. It accepts all records and\n * passes them for exporting.\n */\nexport class UngroupedProcessor extends Processor {\n  aggregatorFor(metricDescriptor: MetricDescriptor): Aggregator {\n    switch (metricDescriptor.metricKind) {\n      case MetricKind.COUNTER:\n      case MetricKind.UP_DOWN_COUNTER:\n        return new aggregators.SumAggregator();\n\n      case MetricKind.SUM_OBSERVER:\n      case MetricKind.UP_DOWN_SUM_OBSERVER:\n      case MetricKind.VALUE_OBSERVER:\n        return new aggregators.LastValueAggregator();\n\n      case MetricKind.VALUE_RECORDER:\n        return new aggregators.HistogramAggregator(\n          metricDescriptor.boundaries || [Infinity]\n        );\n\n      default:\n        return new aggregators.LastValueAggregator();\n    }\n  }\n\n  process(record: MetricRecord): void {\n    const labels = Object.keys(record.labels)\n      .map(k => `${k}=${record.labels[k]}`)\n      .join(',');\n    this._batchMap.set(record.descriptor.name + labels, record);\n  }\n}\n"],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgBA,OAAO,KAAKA,WAAW,MAAM,eAAe;AAC5C,SAEEC,UAAU,QAGL,SAAS;AAEhB;;;;;;;AAOA,IAAAC,SAAA;EAAA,SAAAA,UAAA;IACqB,KAAAC,SAAS,GAAG,IAAIC,GAAG,EAAwB;EAWhE;EAHEF,SAAA,CAAAG,SAAA,CAAAC,aAAa,GAAb;IACE,OAAOC,KAAK,CAACC,IAAI,CAAC,IAAI,CAACL,SAAS,CAACM,MAAM,EAAE,CAAC;EAC5C,CAAC;EACH,OAAAP,SAAC;AAAD,CAAC,CAZD;;AAcA;;;;AAIA,IAAAQ,kBAAA,0BAAAC,MAAA;EAAwCC,SAAA,CAAAF,kBAAA,EAAAC,MAAA;EAAxC,SAAAD,mBAAA;;EA4BA;EA3BEA,kBAAA,CAAAL,SAAA,CAAAQ,aAAa,GAAb,UAAcC,gBAAkC;IAC9C,QAAQA,gBAAgB,CAACC,UAAU;MACjC,KAAKd,UAAU,CAACe,OAAO;MACvB,KAAKf,UAAU,CAACgB,eAAe;QAC7B,OAAO,IAAIjB,WAAW,CAACkB,aAAa,EAAE;MAExC,KAAKjB,UAAU,CAACkB,YAAY;MAC5B,KAAKlB,UAAU,CAACmB,oBAAoB;MACpC,KAAKnB,UAAU,CAACoB,cAAc;QAC5B,OAAO,IAAIrB,WAAW,CAACsB,mBAAmB,EAAE;MAE9C,KAAKrB,UAAU,CAACsB,cAAc;QAC5B,OAAO,IAAIvB,WAAW,CAACwB,mBAAmB,CACxCV,gBAAgB,CAACW,UAAU,IAAI,CAACC,QAAQ,CAAC,CAC1C;MAEH;QACE,OAAO,IAAI1B,WAAW,CAACsB,mBAAmB,EAAE;;EAElD,CAAC;EAEDZ,kBAAA,CAAAL,SAAA,CAAAsB,OAAO,GAAP,UAAQC,MAAoB;IAC1B,IAAMC,MAAM,GAAGC,MAAM,CAACC,IAAI,CAACH,MAAM,CAACC,MAAM,CAAC,CACtCG,GAAG,CAAC,UAAAC,CAAC;MAAI,OAAGA,CAAC,SAAIL,MAAM,CAACC,MAAM,CAACI,CAAC,CAAG;IAA1B,CAA0B,CAAC,CACpCC,IAAI,CAAC,GAAG,CAAC;IACZ,IAAI,CAAC/B,SAAS,CAACgC,GAAG,CAACP,MAAM,CAACQ,UAAU,CAACC,IAAI,GAAGR,MAAM,EAAED,MAAM,CAAC;EAC7D,CAAC;EACH,OAAAlB,kBAAC;AAAD,CAAC,CA5BuCR,SAAS","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}