{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as core from '@opentelemetry/core';\nimport { OTLP_SPAN_KIND_MAPPING, opentelemetryProto } from './types';\nvar MAX_INTEGER_VALUE = 2147483647;\nvar MIN_INTEGER_VALUE = -2147483648;\n/**\n * Converts attributes to KeyValue array\n * @param attributes\n */\nexport function toCollectorAttributes(attributes) {\n  return Object.keys(attributes).map(function (key) {\n    return toCollectorAttributeKeyValue(key, attributes[key]);\n  });\n}\n/**\n * Converts array of unknown value to ArrayValue\n * @param values\n */\nexport function toCollectorArrayValue(values) {\n  return {\n    values: values.map(function (value) {\n      return toCollectorAnyValue(value);\n    })\n  };\n}\n/**\n * Converts attributes to KeyValueList\n * @param attributes\n */\nexport function toCollectorKeyValueList(attributes) {\n  return {\n    values: toCollectorAttributes(attributes)\n  };\n}\n/**\n * Converts key and unknown value to KeyValue\n * @param value event value\n */\nexport function toCollectorAttributeKeyValue(key, value) {\n  var anyValue = toCollectorAnyValue(value);\n  return {\n    key: key,\n    value: anyValue\n  };\n}\n/**\n * Converts unknown value to AnyValue\n * @param value\n */\nexport function toCollectorAnyValue(value) {\n  var anyValue = {};\n  if (typeof value === 'string') {\n    anyValue.stringValue = value;\n  } else if (typeof value === 'boolean') {\n    anyValue.boolValue = value;\n  } else if (typeof value === 'number' && value <= MAX_INTEGER_VALUE && value >= MIN_INTEGER_VALUE && Number.isInteger(value)) {\n    anyValue.intValue = value;\n  } else if (typeof value === 'number') {\n    anyValue.doubleValue = value;\n  } else if (Array.isArray(value)) {\n    anyValue.arrayValue = toCollectorArrayValue(value);\n  } else if (value) {\n    anyValue.kvlistValue = toCollectorKeyValueList(value);\n  }\n  return anyValue;\n}\n/**\n *\n * Converts events\n * @param events array of events\n */\nexport function toCollectorEvents(timedEvents) {\n  return timedEvents.map(function (timedEvent) {\n    var timeUnixNano = core.hrTimeToNanoseconds(timedEvent.time);\n    var name = timedEvent.name;\n    var attributes = toCollectorAttributes(timedEvent.attributes || {});\n    var droppedAttributesCount = 0;\n    var protoEvent = {\n      timeUnixNano: timeUnixNano,\n      name: name,\n      attributes: attributes,\n      droppedAttributesCount: droppedAttributesCount\n    };\n    return protoEvent;\n  });\n}\n/**\n * Converts links\n * @param span\n * @param useHex - if ids should be kept as hex without converting to base64\n */\nfunction toCollectorLinks(span, useHex) {\n  return span.links.map(function (link) {\n    var protoLink = {\n      traceId: useHex ? link.context.traceId : core.hexToBase64(link.context.traceId),\n      spanId: useHex ? link.context.spanId : core.hexToBase64(link.context.spanId),\n      attributes: toCollectorAttributes(link.attributes || {}),\n      droppedAttributesCount: 0\n    };\n    return protoLink;\n  });\n}\n/**\n * Converts span\n * @param span\n * @param useHex - if ids should be kept as hex without converting to base64\n */\nexport function toCollectorSpan(span, useHex) {\n  return {\n    traceId: useHex ? span.spanContext().traceId : core.hexToBase64(span.spanContext().traceId),\n    spanId: useHex ? span.spanContext().spanId : core.hexToBase64(span.spanContext().spanId),\n    parentSpanId: span.parentSpanId ? useHex ? span.parentSpanId : core.hexToBase64(span.parentSpanId) : undefined,\n    traceState: toCollectorTraceState(span.spanContext().traceState),\n    name: span.name,\n    kind: toCollectorKind(span.kind),\n    startTimeUnixNano: core.hrTimeToNanoseconds(span.startTime),\n    endTimeUnixNano: core.hrTimeToNanoseconds(span.endTime),\n    attributes: toCollectorAttributes(span.attributes),\n    droppedAttributesCount: 0,\n    events: toCollectorEvents(span.events),\n    droppedEventsCount: 0,\n    status: toCollectorStatus(span.status),\n    links: toCollectorLinks(span, useHex),\n    droppedLinksCount: 0\n  };\n}\n/**\n * Converts status\n * @param status\n */\nexport function toCollectorStatus(status) {\n  var spanStatus = {\n    code: status.code\n  };\n  if (typeof status.message !== 'undefined') {\n    spanStatus.message = status.message;\n  }\n  return spanStatus;\n}\n/**\n * Converts resource\n * @param resource\n * @param additionalAttributes\n */\nexport function toCollectorResource(resource, additionalAttributes) {\n  if (additionalAttributes === void 0) {\n    additionalAttributes = {};\n  }\n  var attr = Object.assign({}, additionalAttributes, resource ? resource.attributes : {});\n  var resourceProto = {\n    attributes: toCollectorAttributes(attr),\n    droppedAttributesCount: 0\n  };\n  return resourceProto;\n}\n/**\n * Converts span kind\n * @param kind\n */\nexport function toCollectorKind(kind) {\n  var collectorKind = OTLP_SPAN_KIND_MAPPING[kind];\n  return typeof collectorKind === 'number' ? collectorKind : opentelemetryProto.trace.v1.Span.SpanKind.SPAN_KIND_UNSPECIFIED;\n}\n/**\n * Converts traceState\n * @param traceState\n */\nexport function toCollectorTraceState(traceState) {\n  if (!traceState) return undefined;\n  return traceState.serialize();\n}\n/**\n * Prepares trace service request to be sent to collector\n * @param spans spans\n * @param collectorExporterBase\n * @param useHex - if ids should be kept as hex without converting to base64\n */\nexport function toOTLPExportTraceServiceRequest(spans, collectorTraceExporterBase, useHex) {\n  var groupedSpans = groupSpansByResourceAndLibrary(spans);\n  var additionalAttributes = Object.assign({}, collectorTraceExporterBase.attributes);\n  return {\n    resourceSpans: toCollectorResourceSpans(groupedSpans, additionalAttributes, useHex)\n  };\n}\n/**\n * Takes an array of spans and groups them by resource and instrumentation\n * library\n * @param spans spans\n */\nexport function groupSpansByResourceAndLibrary(spans) {\n  return spans.reduce(function (spanMap, span) {\n    //group by resource\n    var resourceSpans = spanMap.get(span.resource);\n    if (!resourceSpans) {\n      resourceSpans = new Map();\n      spanMap.set(span.resource, resourceSpans);\n    }\n    //group by instrumentation library\n    var libSpans = resourceSpans.get(span.instrumentationLibrary);\n    if (!libSpans) {\n      libSpans = new Array();\n      resourceSpans.set(span.instrumentationLibrary, libSpans);\n    }\n    libSpans.push(span);\n    return spanMap;\n  }, new Map());\n}\n/**\n * Convert to InstrumentationLibrarySpans\n * @param instrumentationLibrary\n * @param spans\n * @param useHex - if ids should be kept as hex without converting to base64\n */\nfunction toCollectorInstrumentationLibrarySpans(instrumentationLibrary, spans, useHex) {\n  return {\n    spans: spans.map(function (span) {\n      return toCollectorSpan(span, useHex);\n    }),\n    instrumentationLibrary: instrumentationLibrary\n  };\n}\n/**\n * Returns a list of resource spans which will be exported to the collector\n * @param groupedSpans\n * @param baseAttributes\n * @param useHex - if ids should be kept as hex without converting to base64\n */\nfunction toCollectorResourceSpans(groupedSpans, baseAttributes, useHex) {\n  return Array.from(groupedSpans, function (_a) {\n    var resource = _a[0],\n      libSpans = _a[1];\n    return {\n      resource: toCollectorResource(resource, baseAttributes),\n      instrumentationLibrarySpans: Array.from(libSpans, function (_a) {\n        var instrumentationLibrary = _a[0],\n          spans = _a[1];\n        return toCollectorInstrumentationLibrarySpans(instrumentationLibrary, spans, useHex);\n      })\n    };\n  });\n}","map":{"version":3,"names":["core","OTLP_SPAN_KIND_MAPPING","opentelemetryProto","MAX_INTEGER_VALUE","MIN_INTEGER_VALUE","toCollectorAttributes","attributes","Object","keys","map","key","toCollectorAttributeKeyValue","toCollectorArrayValue","values","value","toCollectorAnyValue","toCollectorKeyValueList","anyValue","stringValue","boolValue","Number","isInteger","intValue","doubleValue","Array","isArray","arrayValue","kvlistValue","toCollectorEvents","timedEvents","timedEvent","timeUnixNano","hrTimeToNanoseconds","time","name","droppedAttributesCount","protoEvent","toCollectorLinks","span","useHex","links","link","protoLink","traceId","context","hexToBase64","spanId","toCollectorSpan","spanContext","parentSpanId","undefined","traceState","toCollectorTraceState","kind","toCollectorKind","startTimeUnixNano","startTime","endTimeUnixNano","endTime","events","droppedEventsCount","status","toCollectorStatus","droppedLinksCount","spanStatus","code","message","toCollectorResource","resource","additionalAttributes","attr","assign","resourceProto","collectorKind","trace","v1","Span","SpanKind","SPAN_KIND_UNSPECIFIED","serialize","toOTLPExportTraceServiceRequest","spans","collectorTraceExporterBase","groupedSpans","groupSpansByResourceAndLibrary","resourceSpans","toCollectorResourceSpans","reduce","spanMap","get","Map","set","libSpans","instrumentationLibrary","push","toCollectorInstrumentationLibrarySpans","baseAttributes","from","_a","instrumentationLibrarySpans"],"sources":["C:\\Users\\Sartaj\\Desktop\\ObservaCart\\observacart\\frontend\\node_modules\\@opentelemetry\\exporter-otlp-http\\src\\transform.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  SpanAttributes,\n  Link,\n  SpanKind,\n  SpanStatus,\n  TraceState,\n} from '@opentelemetry/api';\nimport * as core from '@opentelemetry/core';\nimport { Resource } from '@opentelemetry/resources';\nimport { ReadableSpan, TimedEvent } from '@opentelemetry/sdk-trace-base';\nimport { OTLPExporterBase } from './OTLPExporterBase';\nimport {\n  OTLP_SPAN_KIND_MAPPING,\n  opentelemetryProto,\n  OTLPExporterConfigBase,\n} from './types';\n\nconst MAX_INTEGER_VALUE = 2147483647;\nconst MIN_INTEGER_VALUE = -2147483648;\n\n/**\n * Converts attributes to KeyValue array\n * @param attributes\n */\nexport function toCollectorAttributes(\n  attributes: SpanAttributes\n): opentelemetryProto.common.v1.KeyValue[] {\n  return Object.keys(attributes).map(key => {\n    return toCollectorAttributeKeyValue(key, attributes[key]);\n  });\n}\n\n/**\n * Converts array of unknown value to ArrayValue\n * @param values\n */\nexport function toCollectorArrayValue(\n  values: unknown[]\n): opentelemetryProto.common.v1.ArrayValue {\n  return {\n    values: values.map(value => toCollectorAnyValue(value)),\n  };\n}\n\n/**\n * Converts attributes to KeyValueList\n * @param attributes\n */\nexport function toCollectorKeyValueList(\n  attributes: SpanAttributes\n): opentelemetryProto.common.v1.KeyValueList {\n  return {\n    values: toCollectorAttributes(attributes),\n  };\n}\n\n/**\n * Converts key and unknown value to KeyValue\n * @param value event value\n */\nexport function toCollectorAttributeKeyValue(\n  key: string,\n  value: unknown\n): opentelemetryProto.common.v1.KeyValue {\n  const anyValue = toCollectorAnyValue(value);\n  return {\n    key,\n    value: anyValue,\n  };\n}\n\n/**\n * Converts unknown value to AnyValue\n * @param value\n */\nexport function toCollectorAnyValue(\n  value: unknown\n): opentelemetryProto.common.v1.AnyValue {\n  const anyValue: opentelemetryProto.common.v1.AnyValue = {};\n  if (typeof value === 'string') {\n    anyValue.stringValue = value;\n  } else if (typeof value === 'boolean') {\n    anyValue.boolValue = value;\n  } else if (\n    typeof value === 'number' &&\n    value <= MAX_INTEGER_VALUE &&\n    value >= MIN_INTEGER_VALUE &&\n    Number.isInteger(value)\n  ) {\n    anyValue.intValue = value;\n  } else if (typeof value === 'number') {\n    anyValue.doubleValue = value;\n  } else if (Array.isArray(value)) {\n    anyValue.arrayValue = toCollectorArrayValue(value);\n  } else if (value) {\n    anyValue.kvlistValue = toCollectorKeyValueList(value as SpanAttributes);\n  }\n  return anyValue;\n}\n\n/**\n *\n * Converts events\n * @param events array of events\n */\nexport function toCollectorEvents(\n  timedEvents: TimedEvent[]\n): opentelemetryProto.trace.v1.Span.Event[] {\n  return timedEvents.map(timedEvent => {\n    const timeUnixNano = core.hrTimeToNanoseconds(timedEvent.time);\n    const name = timedEvent.name;\n    const attributes = toCollectorAttributes(timedEvent.attributes || {});\n    const droppedAttributesCount = 0;\n\n    const protoEvent: opentelemetryProto.trace.v1.Span.Event = {\n      timeUnixNano,\n      name,\n      attributes,\n      droppedAttributesCount,\n    };\n\n    return protoEvent;\n  });\n}\n\n/**\n * Converts links\n * @param span\n * @param useHex - if ids should be kept as hex without converting to base64\n */\nfunction toCollectorLinks(\n  span: ReadableSpan,\n  useHex?: boolean\n): opentelemetryProto.trace.v1.Span.Link[] {\n  return span.links.map((link: Link) => {\n    const protoLink: opentelemetryProto.trace.v1.Span.Link = {\n      traceId: useHex\n        ? link.context.traceId\n        : core.hexToBase64(link.context.traceId),\n      spanId: useHex\n        ? link.context.spanId\n        : core.hexToBase64(link.context.spanId),\n      attributes: toCollectorAttributes(link.attributes || {}),\n      droppedAttributesCount: 0,\n    };\n    return protoLink;\n  });\n}\n\n/**\n * Converts span\n * @param span\n * @param useHex - if ids should be kept as hex without converting to base64\n */\nexport function toCollectorSpan(\n  span: ReadableSpan,\n  useHex?: boolean\n): opentelemetryProto.trace.v1.Span {\n  return {\n    traceId: useHex\n      ? span.spanContext().traceId\n      : core.hexToBase64(span.spanContext().traceId),\n    spanId: useHex\n      ? span.spanContext().spanId\n      : core.hexToBase64(span.spanContext().spanId),\n    parentSpanId: span.parentSpanId\n      ? useHex\n        ? span.parentSpanId\n        : core.hexToBase64(span.parentSpanId)\n      : undefined,\n    traceState: toCollectorTraceState(span.spanContext().traceState),\n    name: span.name,\n    kind: toCollectorKind(span.kind),\n    startTimeUnixNano: core.hrTimeToNanoseconds(span.startTime),\n    endTimeUnixNano: core.hrTimeToNanoseconds(span.endTime),\n    attributes: toCollectorAttributes(span.attributes),\n    droppedAttributesCount: 0,\n    events: toCollectorEvents(span.events),\n    droppedEventsCount: 0,\n    status: toCollectorStatus(span.status),\n    links: toCollectorLinks(span, useHex),\n    droppedLinksCount: 0,\n  };\n}\n\n/**\n * Converts status\n * @param status\n */\nexport function toCollectorStatus(\n  status: SpanStatus\n): opentelemetryProto.trace.v1.SpanStatus {\n  const spanStatus: opentelemetryProto.trace.v1.SpanStatus = {\n    code: status.code,\n  };\n  if (typeof status.message !== 'undefined') {\n    spanStatus.message = status.message;\n  }\n  return spanStatus;\n}\n\n/**\n * Converts resource\n * @param resource\n * @param additionalAttributes\n */\nexport function toCollectorResource(\n  resource?: Resource,\n  additionalAttributes: { [key: string]: unknown } = {}\n): opentelemetryProto.resource.v1.Resource {\n  const attr = Object.assign(\n    {},\n    additionalAttributes,\n    resource ? resource.attributes : {}\n  );\n  const resourceProto: opentelemetryProto.resource.v1.Resource = {\n    attributes: toCollectorAttributes(attr),\n    droppedAttributesCount: 0,\n  };\n\n  return resourceProto;\n}\n\n/**\n * Converts span kind\n * @param kind\n */\nexport function toCollectorKind(\n  kind: SpanKind\n): opentelemetryProto.trace.v1.Span.SpanKind {\n  const collectorKind = OTLP_SPAN_KIND_MAPPING[kind];\n  return typeof collectorKind === 'number'\n    ? collectorKind\n    : opentelemetryProto.trace.v1.Span.SpanKind.SPAN_KIND_UNSPECIFIED;\n}\n\n/**\n * Converts traceState\n * @param traceState\n */\nexport function toCollectorTraceState(\n  traceState?: TraceState\n): opentelemetryProto.trace.v1.Span.TraceState | undefined {\n  if (!traceState) return undefined;\n  return traceState.serialize();\n}\n\n/**\n * Prepares trace service request to be sent to collector\n * @param spans spans\n * @param collectorExporterBase\n * @param useHex - if ids should be kept as hex without converting to base64\n */\nexport function toOTLPExportTraceServiceRequest<\n  T extends OTLPExporterConfigBase\n>(\n  spans: ReadableSpan[],\n  collectorTraceExporterBase: OTLPExporterBase<\n    T,\n    ReadableSpan,\n    opentelemetryProto.collector.trace.v1.ExportTraceServiceRequest\n  >,\n  useHex?: boolean\n): opentelemetryProto.collector.trace.v1.ExportTraceServiceRequest {\n  const groupedSpans: Map<\n    Resource,\n    Map<core.InstrumentationLibrary, ReadableSpan[]>\n  > = groupSpansByResourceAndLibrary(spans);\n\n  const additionalAttributes = Object.assign(\n    {},\n    collectorTraceExporterBase.attributes\n  );\n\n  return {\n    resourceSpans: toCollectorResourceSpans(\n      groupedSpans,\n      additionalAttributes,\n      useHex\n    ),\n  };\n}\n\n/**\n * Takes an array of spans and groups them by resource and instrumentation\n * library\n * @param spans spans\n */\nexport function groupSpansByResourceAndLibrary(\n  spans: ReadableSpan[]\n): Map<Resource, Map<core.InstrumentationLibrary, ReadableSpan[]>> {\n  return spans.reduce((spanMap, span) => {\n    //group by resource\n    let resourceSpans = spanMap.get(span.resource);\n    if (!resourceSpans) {\n      resourceSpans = new Map<core.InstrumentationLibrary, ReadableSpan[]>();\n      spanMap.set(span.resource, resourceSpans);\n    }\n    //group by instrumentation library\n    let libSpans = resourceSpans.get(span.instrumentationLibrary);\n    if (!libSpans) {\n      libSpans = new Array<ReadableSpan>();\n      resourceSpans.set(span.instrumentationLibrary, libSpans);\n    }\n    libSpans.push(span);\n    return spanMap;\n  }, new Map<Resource, Map<core.InstrumentationLibrary, ReadableSpan[]>>());\n}\n\n/**\n * Convert to InstrumentationLibrarySpans\n * @param instrumentationLibrary\n * @param spans\n * @param useHex - if ids should be kept as hex without converting to base64\n */\nfunction toCollectorInstrumentationLibrarySpans(\n  instrumentationLibrary: core.InstrumentationLibrary,\n  spans: ReadableSpan[],\n  useHex?: boolean\n): opentelemetryProto.trace.v1.InstrumentationLibrarySpans {\n  return {\n    spans: spans.map(span => toCollectorSpan(span, useHex)),\n    instrumentationLibrary,\n  };\n}\n\n/**\n * Returns a list of resource spans which will be exported to the collector\n * @param groupedSpans\n * @param baseAttributes\n * @param useHex - if ids should be kept as hex without converting to base64\n */\nfunction toCollectorResourceSpans(\n  groupedSpans: Map<Resource, Map<core.InstrumentationLibrary, ReadableSpan[]>>,\n  baseAttributes: SpanAttributes,\n  useHex?: boolean\n): opentelemetryProto.trace.v1.ResourceSpans[] {\n  return Array.from(groupedSpans, ([resource, libSpans]) => {\n    return {\n      resource: toCollectorResource(resource, baseAttributes),\n      instrumentationLibrarySpans: Array.from(\n        libSpans,\n        ([instrumentationLibrary, spans]) =>\n          toCollectorInstrumentationLibrarySpans(\n            instrumentationLibrary,\n            spans,\n            useHex\n          )\n      ),\n    };\n  });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}