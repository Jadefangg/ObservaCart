{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { ValueType } from '@opentelemetry/api-metrics';\nimport * as core from '@opentelemetry/core';\nimport { AggregatorKind, MetricKind } from '@opentelemetry/sdk-metrics-base';\nimport { toCollectorResource } from './transform';\nimport { opentelemetryProto } from './types';\n/**\n * Converts labels\n * @param labels\n */\nexport function toCollectorLabels(labels) {\n  return Object.entries(labels).map(function (_a) {\n    var key = _a[0],\n      value = _a[1];\n    return {\n      key: key,\n      value: String(value)\n    };\n  });\n}\n/**\n * Given a MetricDescriptor, return its temporality in a compatible format with the collector\n * @param descriptor\n */\nexport function toAggregationTemporality(metric) {\n  if (metric.descriptor.metricKind === MetricKind.VALUE_OBSERVER) {\n    return opentelemetryProto.metrics.v1.AggregationTemporality.AGGREGATION_TEMPORALITY_UNSPECIFIED;\n  }\n  return metric.aggregationTemporality;\n}\n/**\n * Returns an DataPoint which can have integers or doublle values\n * @param metric\n * @param startTime\n */\nexport function toDataPoint(metric, startTime) {\n  return {\n    labels: toCollectorLabels(metric.labels),\n    value: metric.aggregator.toPoint().value,\n    startTimeUnixNano: startTime,\n    timeUnixNano: core.hrTimeToNanoseconds(metric.aggregator.toPoint().timestamp)\n  };\n}\n/**\n * Returns a HistogramPoint to the collector\n * @param metric\n * @param startTime\n */\nexport function toHistogramPoint(metric, startTime) {\n  var _a = metric.aggregator.toPoint(),\n    value = _a.value,\n    timestamp = _a.timestamp;\n  return {\n    labels: toCollectorLabels(metric.labels),\n    sum: value.sum,\n    count: value.count,\n    startTimeUnixNano: startTime,\n    timeUnixNano: core.hrTimeToNanoseconds(timestamp),\n    bucketCounts: value.buckets.counts,\n    explicitBounds: value.buckets.boundaries\n  };\n}\n/**\n * Converts a metric to be compatible with the collector\n * @param metric\n * @param startTime start time in nanoseconds\n */\nexport function toCollectorMetric(metric, startTime) {\n  var metricCollector = {\n    name: metric.descriptor.name,\n    description: metric.descriptor.description,\n    unit: metric.descriptor.unit\n  };\n  if (metric.aggregator.kind === AggregatorKind.SUM || metric.descriptor.metricKind === MetricKind.SUM_OBSERVER || metric.descriptor.metricKind === MetricKind.UP_DOWN_SUM_OBSERVER) {\n    var result = {\n      dataPoints: [toDataPoint(metric, startTime)],\n      isMonotonic: metric.descriptor.metricKind === MetricKind.COUNTER || metric.descriptor.metricKind === MetricKind.SUM_OBSERVER,\n      aggregationTemporality: toAggregationTemporality(metric)\n    };\n    if (metric.descriptor.valueType === ValueType.INT) {\n      metricCollector.intSum = result;\n    } else {\n      metricCollector.doubleSum = result;\n    }\n  } else if (metric.aggregator.kind === AggregatorKind.LAST_VALUE) {\n    var result = {\n      dataPoints: [toDataPoint(metric, startTime)]\n    };\n    if (metric.descriptor.valueType === ValueType.INT) {\n      metricCollector.intGauge = result;\n    } else {\n      metricCollector.doubleGauge = result;\n    }\n  } else if (metric.aggregator.kind === AggregatorKind.HISTOGRAM) {\n    var result = {\n      dataPoints: [toHistogramPoint(metric, startTime)],\n      aggregationTemporality: toAggregationTemporality(metric)\n    };\n    if (metric.descriptor.valueType === ValueType.INT) {\n      metricCollector.intHistogram = result;\n    } else {\n      metricCollector.doubleHistogram = result;\n    }\n  }\n  return metricCollector;\n}\n/**\n * Prepares metric service request to be sent to collector\n * @param metrics metrics\n * @param startTime start time of the metric in nanoseconds\n * @param collectorMetricExporterBase\n */\nexport function toOTLPExportMetricServiceRequest(metrics, startTime, collectorExporterBase) {\n  var groupedMetrics = groupMetricsByResourceAndLibrary(metrics);\n  var additionalAttributes = Object.assign({}, collectorExporterBase.attributes);\n  return {\n    resourceMetrics: toCollectorResourceMetrics(groupedMetrics, additionalAttributes, startTime)\n  };\n}\n/**\n * Takes an array of metrics and groups them by resource and instrumentation\n * library\n * @param metrics metrics\n */\nexport function groupMetricsByResourceAndLibrary(metrics) {\n  return metrics.reduce(function (metricMap, metric) {\n    //group by resource\n    var resourceMetrics = metricMap.get(metric.resource);\n    if (!resourceMetrics) {\n      resourceMetrics = new Map();\n      metricMap.set(metric.resource, resourceMetrics);\n    }\n    //group by instrumentation library\n    var libMetrics = resourceMetrics.get(metric.instrumentationLibrary);\n    if (!libMetrics) {\n      libMetrics = new Array();\n      resourceMetrics.set(metric.instrumentationLibrary, libMetrics);\n    }\n    libMetrics.push(metric);\n    return metricMap;\n  }, new Map());\n}\n/**\n * Convert to InstrumentationLibraryMetrics\n * @param instrumentationLibrary\n * @param metrics\n * @param startTime\n */\nfunction toCollectorInstrumentationLibraryMetrics(instrumentationLibrary, metrics, startTime) {\n  return {\n    metrics: metrics.map(function (metric) {\n      return toCollectorMetric(metric, startTime);\n    }),\n    instrumentationLibrary: instrumentationLibrary\n  };\n}\n/**\n * Returns a list of resource metrics which will be exported to the collector\n * @param groupedSpans\n * @param baseAttributes\n */\nfunction toCollectorResourceMetrics(groupedMetrics, baseAttributes, startTime) {\n  return Array.from(groupedMetrics, function (_a) {\n    var resource = _a[0],\n      libMetrics = _a[1];\n    return {\n      resource: toCollectorResource(resource, baseAttributes),\n      instrumentationLibraryMetrics: Array.from(libMetrics, function (_a) {\n        var instrumentationLibrary = _a[0],\n          metrics = _a[1];\n        return toCollectorInstrumentationLibraryMetrics(instrumentationLibrary, metrics, startTime);\n      })\n    };\n  });\n}","map":{"version":3,"names":["ValueType","core","AggregatorKind","MetricKind","toCollectorResource","opentelemetryProto","toCollectorLabels","labels","Object","entries","map","_a","key","value","String","toAggregationTemporality","metric","descriptor","metricKind","VALUE_OBSERVER","metrics","v1","AggregationTemporality","AGGREGATION_TEMPORALITY_UNSPECIFIED","aggregationTemporality","toDataPoint","startTime","aggregator","toPoint","startTimeUnixNano","timeUnixNano","hrTimeToNanoseconds","timestamp","toHistogramPoint","sum","count","bucketCounts","buckets","counts","explicitBounds","boundaries","toCollectorMetric","metricCollector","name","description","unit","kind","SUM","SUM_OBSERVER","UP_DOWN_SUM_OBSERVER","result","dataPoints","isMonotonic","COUNTER","valueType","INT","intSum","doubleSum","LAST_VALUE","intGauge","doubleGauge","HISTOGRAM","intHistogram","doubleHistogram","toOTLPExportMetricServiceRequest","collectorExporterBase","groupedMetrics","groupMetricsByResourceAndLibrary","additionalAttributes","assign","attributes","resourceMetrics","toCollectorResourceMetrics","reduce","metricMap","get","resource","Map","set","libMetrics","instrumentationLibrary","Array","push","toCollectorInstrumentationLibraryMetrics","baseAttributes","from","instrumentationLibraryMetrics"],"sources":["C:\\Users\\Sartaj\\Desktop\\ObservaCart\\observacart\\frontend\\node_modules\\@opentelemetry\\exporter-otlp-http\\src\\transformMetrics.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { SpanAttributes, HrTime } from '@opentelemetry/api';\nimport { Labels, ValueType } from '@opentelemetry/api-metrics';\nimport * as core from '@opentelemetry/core';\nimport {\n  AggregatorKind,\n  Histogram,\n  MetricKind,\n  MetricRecord,\n} from '@opentelemetry/sdk-metrics-base';\nimport { Resource } from '@opentelemetry/resources';\nimport { OTLPExporterBase } from './OTLPExporterBase';\nimport { toCollectorResource } from './transform';\nimport { OTLPExporterConfigBase, opentelemetryProto } from './types';\n\n/**\n * Converts labels\n * @param labels\n */\nexport function toCollectorLabels(\n  labels: Labels\n): opentelemetryProto.common.v1.StringKeyValue[] {\n  return Object.entries(labels).map(([key, value]) => {\n    return { key, value: String(value) };\n  });\n}\n\n/**\n * Given a MetricDescriptor, return its temporality in a compatible format with the collector\n * @param descriptor\n */\nexport function toAggregationTemporality(\n  metric: MetricRecord\n): opentelemetryProto.metrics.v1.AggregationTemporality {\n  if (metric.descriptor.metricKind === MetricKind.VALUE_OBSERVER) {\n    return opentelemetryProto.metrics.v1.AggregationTemporality\n      .AGGREGATION_TEMPORALITY_UNSPECIFIED;\n  }\n\n  return metric.aggregationTemporality;\n}\n\n/**\n * Returns an DataPoint which can have integers or doublle values\n * @param metric\n * @param startTime\n */\nexport function toDataPoint(\n  metric: MetricRecord,\n  startTime: number\n): opentelemetryProto.metrics.v1.DataPoint {\n  return {\n    labels: toCollectorLabels(metric.labels),\n    value: metric.aggregator.toPoint().value as number,\n    startTimeUnixNano: startTime,\n    timeUnixNano: core.hrTimeToNanoseconds(\n      metric.aggregator.toPoint().timestamp\n    ),\n  };\n}\n\n/**\n * Returns a HistogramPoint to the collector\n * @param metric\n * @param startTime\n */\nexport function toHistogramPoint(\n  metric: MetricRecord,\n  startTime: number\n): opentelemetryProto.metrics.v1.HistogramDataPoint {\n  const { value, timestamp } = metric.aggregator.toPoint() as {\n    value: Histogram;\n    timestamp: HrTime;\n  };\n  return {\n    labels: toCollectorLabels(metric.labels),\n    sum: value.sum,\n    count: value.count,\n    startTimeUnixNano: startTime,\n    timeUnixNano: core.hrTimeToNanoseconds(timestamp),\n    bucketCounts: value.buckets.counts,\n    explicitBounds: value.buckets.boundaries,\n  };\n}\n\n/**\n * Converts a metric to be compatible with the collector\n * @param metric\n * @param startTime start time in nanoseconds\n */\nexport function toCollectorMetric(\n  metric: MetricRecord,\n  startTime: number\n): opentelemetryProto.metrics.v1.Metric {\n  const metricCollector: opentelemetryProto.metrics.v1.Metric = {\n    name: metric.descriptor.name,\n    description: metric.descriptor.description,\n    unit: metric.descriptor.unit,\n  };\n\n  if (\n    metric.aggregator.kind === AggregatorKind.SUM ||\n    metric.descriptor.metricKind === MetricKind.SUM_OBSERVER ||\n    metric.descriptor.metricKind === MetricKind.UP_DOWN_SUM_OBSERVER\n  ) {\n    const result = {\n      dataPoints: [toDataPoint(metric, startTime)],\n      isMonotonic:\n        metric.descriptor.metricKind === MetricKind.COUNTER ||\n        metric.descriptor.metricKind === MetricKind.SUM_OBSERVER,\n      aggregationTemporality: toAggregationTemporality(metric),\n    };\n    if (metric.descriptor.valueType === ValueType.INT) {\n      metricCollector.intSum = result;\n    } else {\n      metricCollector.doubleSum = result;\n    }\n  } else if (metric.aggregator.kind === AggregatorKind.LAST_VALUE) {\n    const result = {\n      dataPoints: [toDataPoint(metric, startTime)],\n    };\n    if (metric.descriptor.valueType === ValueType.INT) {\n      metricCollector.intGauge = result;\n    } else {\n      metricCollector.doubleGauge = result;\n    }\n  } else if (metric.aggregator.kind === AggregatorKind.HISTOGRAM) {\n    const result = {\n      dataPoints: [toHistogramPoint(metric, startTime)],\n      aggregationTemporality: toAggregationTemporality(metric),\n    };\n    if (metric.descriptor.valueType === ValueType.INT) {\n      metricCollector.intHistogram = result;\n    } else {\n      metricCollector.doubleHistogram = result;\n    }\n  }\n\n  return metricCollector;\n}\n\n/**\n * Prepares metric service request to be sent to collector\n * @param metrics metrics\n * @param startTime start time of the metric in nanoseconds\n * @param collectorMetricExporterBase\n */\nexport function toOTLPExportMetricServiceRequest<\n  T extends OTLPExporterConfigBase\n>(\n  metrics: MetricRecord[],\n  startTime: number,\n  collectorExporterBase: OTLPExporterBase<\n    T,\n    MetricRecord,\n    opentelemetryProto.collector.metrics.v1.ExportMetricsServiceRequest\n  >\n): opentelemetryProto.collector.metrics.v1.ExportMetricsServiceRequest {\n  const groupedMetrics: Map<\n    Resource,\n    Map<core.InstrumentationLibrary, MetricRecord[]>\n  > = groupMetricsByResourceAndLibrary(metrics);\n  const additionalAttributes = Object.assign(\n    {},\n    collectorExporterBase.attributes\n  );\n  return {\n    resourceMetrics: toCollectorResourceMetrics(\n      groupedMetrics,\n      additionalAttributes,\n      startTime\n    ),\n  };\n}\n\n/**\n * Takes an array of metrics and groups them by resource and instrumentation\n * library\n * @param metrics metrics\n */\nexport function groupMetricsByResourceAndLibrary(\n  metrics: MetricRecord[]\n): Map<Resource, Map<core.InstrumentationLibrary, MetricRecord[]>> {\n  return metrics.reduce((metricMap, metric) => {\n    //group by resource\n    let resourceMetrics = metricMap.get(metric.resource);\n    if (!resourceMetrics) {\n      resourceMetrics = new Map<core.InstrumentationLibrary, MetricRecord[]>();\n      metricMap.set(metric.resource, resourceMetrics);\n    }\n    //group by instrumentation library\n    let libMetrics = resourceMetrics.get(metric.instrumentationLibrary);\n    if (!libMetrics) {\n      libMetrics = new Array<MetricRecord>();\n      resourceMetrics.set(metric.instrumentationLibrary, libMetrics);\n    }\n    libMetrics.push(metric);\n    return metricMap;\n  }, new Map<Resource, Map<core.InstrumentationLibrary, MetricRecord[]>>());\n}\n\n/**\n * Convert to InstrumentationLibraryMetrics\n * @param instrumentationLibrary\n * @param metrics\n * @param startTime\n */\nfunction toCollectorInstrumentationLibraryMetrics(\n  instrumentationLibrary: core.InstrumentationLibrary,\n  metrics: MetricRecord[],\n  startTime: number\n): opentelemetryProto.metrics.v1.InstrumentationLibraryMetrics {\n  return {\n    metrics: metrics.map(metric => toCollectorMetric(metric, startTime)),\n    instrumentationLibrary,\n  };\n}\n\n/**\n * Returns a list of resource metrics which will be exported to the collector\n * @param groupedSpans\n * @param baseAttributes\n */\nfunction toCollectorResourceMetrics(\n  groupedMetrics: Map<\n    Resource,\n    Map<core.InstrumentationLibrary, MetricRecord[]>\n  >,\n  baseAttributes: SpanAttributes,\n  startTime: number\n): opentelemetryProto.metrics.v1.ResourceMetrics[] {\n  return Array.from(groupedMetrics, ([resource, libMetrics]) => {\n    return {\n      resource: toCollectorResource(resource, baseAttributes),\n      instrumentationLibraryMetrics: Array.from(\n        libMetrics,\n        ([instrumentationLibrary, metrics]) =>\n          toCollectorInstrumentationLibraryMetrics(\n            instrumentationLibrary,\n            metrics,\n            startTime\n          )\n      ),\n    };\n  });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}