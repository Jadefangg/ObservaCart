{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n      label: 0,\n      sent: function () {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n    f,\n    y,\n    t,\n    g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n        case 7:\n          op = _.ops.pop();\n          _.trys.pop();\n          continue;\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n            _.ops.push(op);\n            break;\n          }\n          if (t[2]) _.ops.pop();\n          _.trys.pop();\n          continue;\n      }\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\nimport { diag } from '@opentelemetry/api';\nimport * as api from '@opentelemetry/api-metrics';\nimport { Resource } from '@opentelemetry/resources';\nimport { BatchObserver } from './BatchObserver';\nimport { CounterMetric } from './CounterMetric';\nimport { PushController } from './export/Controller';\nimport { NoopExporter } from './export/NoopExporter';\nimport { UngroupedProcessor } from './export/Processor';\nimport { SumObserverMetric } from './SumObserverMetric';\nimport { DEFAULT_CONFIG, DEFAULT_METRIC_OPTIONS } from './types';\nimport { UpDownCounterMetric } from './UpDownCounterMetric';\nimport { UpDownSumObserverMetric } from './UpDownSumObserverMetric';\nimport { ValueObserverMetric } from './ValueObserverMetric';\nimport { ValueRecorderMetric } from './ValueRecorderMetric';\n// eslint-disable-next-line @typescript-eslint/no-var-requires\nvar merge = require('lodash.merge');\n/**\n * Meter is an implementation of the {@link Meter} interface.\n */\nvar Meter = /** @class */function () {\n  /**\n   * Constructs a new Meter instance.\n   */\n  function Meter(instrumentationLibrary, config) {\n    if (config === void 0) {\n      config = {};\n    }\n    var _a;\n    this._batchObservers = [];\n    this._metrics = new Map();\n    this._isShutdown = false;\n    this._shuttingDownPromise = Promise.resolve();\n    var mergedConfig = merge({}, DEFAULT_CONFIG, config);\n    this._processor = (_a = mergedConfig.processor) !== null && _a !== void 0 ? _a : new UngroupedProcessor();\n    this._resource = mergedConfig.resource || Resource.empty();\n    this._instrumentationLibrary = instrumentationLibrary;\n    // start the push controller\n    var exporter = mergedConfig.exporter || new NoopExporter();\n    var interval = mergedConfig.interval;\n    this._controller = new PushController(this, exporter, interval);\n  }\n  /**\n   * Creates and returns a new {@link ValueRecorder}.\n   * @param name the name of the metric.\n   * @param [options] the metric options.\n   */\n  Meter.prototype.createValueRecorder = function (name, options) {\n    if (!this._isValidName(name)) {\n      diag.warn(\"Invalid metric name \" + name + \". Defaulting to noop metric implementation.\");\n      return api.NOOP_VALUE_RECORDER_METRIC;\n    }\n    var opt = __assign(__assign({}, DEFAULT_METRIC_OPTIONS), options);\n    var valueRecorder = new ValueRecorderMetric(name, opt, this._processor, this._resource, this._instrumentationLibrary);\n    this._registerMetric(name, valueRecorder);\n    return valueRecorder;\n  };\n  /**\n   * Creates a new counter metric. Generally, this kind of metric when the\n   * value is a quantity, the sum is of primary interest, and the event count\n   * and value distribution are not of primary interest.\n   * @param name the name of the metric.\n   * @param [options] the metric options.\n   */\n  Meter.prototype.createCounter = function (name, options) {\n    if (!this._isValidName(name)) {\n      diag.warn(\"Invalid metric name \" + name + \". Defaulting to noop metric implementation.\");\n      return api.NOOP_COUNTER_METRIC;\n    }\n    var opt = __assign(__assign({}, DEFAULT_METRIC_OPTIONS), options);\n    var counter = new CounterMetric(name, opt, this._processor, this._resource, this._instrumentationLibrary);\n    this._registerMetric(name, counter);\n    return counter;\n  };\n  /**\n   * Creates a new `UpDownCounter` metric. UpDownCounter is a synchronous\n   * instrument and very similar to Counter except that Add(increment)\n   * supports negative increments. It is generally useful for capturing changes\n   * in an amount of resources used, or any quantity that rises and falls\n   * during a request.\n   *\n   * @param name the name of the metric.\n   * @param [options] the metric options.\n   */\n  Meter.prototype.createUpDownCounter = function (name, options) {\n    if (!this._isValidName(name)) {\n      diag.warn(\"Invalid metric name \" + name + \". Defaulting to noop metric implementation.\");\n      return api.NOOP_COUNTER_METRIC;\n    }\n    var opt = __assign(__assign({}, DEFAULT_METRIC_OPTIONS), options);\n    var upDownCounter = new UpDownCounterMetric(name, opt, this._processor, this._resource, this._instrumentationLibrary);\n    this._registerMetric(name, upDownCounter);\n    return upDownCounter;\n  };\n  /**\n   * Creates a new `ValueObserver` metric.\n   * @param name the name of the metric.\n   * @param [options] the metric options.\n   * @param [callback] the value observer callback\n   */\n  Meter.prototype.createValueObserver = function (name, options, callback) {\n    if (options === void 0) {\n      options = {};\n    }\n    if (!this._isValidName(name)) {\n      diag.warn(\"Invalid metric name \" + name + \". Defaulting to noop metric implementation.\");\n      return api.NOOP_VALUE_OBSERVER_METRIC;\n    }\n    var opt = __assign(__assign({}, DEFAULT_METRIC_OPTIONS), options);\n    var valueObserver = new ValueObserverMetric(name, opt, this._processor, this._resource, this._instrumentationLibrary, callback);\n    this._registerMetric(name, valueObserver);\n    return valueObserver;\n  };\n  Meter.prototype.createSumObserver = function (name, options, callback) {\n    if (options === void 0) {\n      options = {};\n    }\n    if (!this._isValidName(name)) {\n      diag.warn(\"Invalid metric name \" + name + \". Defaulting to noop metric implementation.\");\n      return api.NOOP_SUM_OBSERVER_METRIC;\n    }\n    var opt = __assign(__assign({}, DEFAULT_METRIC_OPTIONS), options);\n    var sumObserver = new SumObserverMetric(name, opt, this._processor, this._resource, this._instrumentationLibrary, callback);\n    this._registerMetric(name, sumObserver);\n    return sumObserver;\n  };\n  /**\n   * Creates a new `UpDownSumObserver` metric.\n   * @param name the name of the metric.\n   * @param [options] the metric options.\n   * @param [callback] the value observer callback\n   */\n  Meter.prototype.createUpDownSumObserver = function (name, options, callback) {\n    if (options === void 0) {\n      options = {};\n    }\n    if (!this._isValidName(name)) {\n      diag.warn(\"Invalid metric name \" + name + \". Defaulting to noop metric implementation.\");\n      return api.NOOP_UP_DOWN_SUM_OBSERVER_METRIC;\n    }\n    var opt = __assign(__assign({}, DEFAULT_METRIC_OPTIONS), options);\n    var upDownSumObserver = new UpDownSumObserverMetric(name, opt, this._processor, this._resource, this._instrumentationLibrary, callback);\n    this._registerMetric(name, upDownSumObserver);\n    return upDownSumObserver;\n  };\n  /**\n   * Creates a new batch observer.\n   * @param callback the batch observer callback\n   * @param [options] the batch options.\n   */\n  Meter.prototype.createBatchObserver = function (callback, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    var opt = __assign({}, options);\n    var batchObserver = new BatchObserver(opt, callback);\n    this._batchObservers.push(batchObserver);\n    return batchObserver;\n  };\n  /**\n   * Collects all the metrics created with this `Meter` for export.\n   *\n   * Utilizes the processor to create checkpoints of the current values in\n   * each aggregator belonging to the metrics that were created with this\n   * meter instance.\n   */\n  Meter.prototype.collect = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var observations, metricsRecords;\n      var _this = this;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            observations = this._batchObservers.map(function (observer) {\n              return observer.collect();\n            });\n            return [4 /*yield*/, Promise.all(observations)];\n          case 1:\n            _a.sent();\n            metricsRecords = Array.from(this._metrics.values()).map(function (metric) {\n              return metric.getMetricRecord();\n            });\n            return [4 /*yield*/, Promise.all(metricsRecords).then(function (records) {\n              records.forEach(function (metrics) {\n                metrics.forEach(function (metric) {\n                  return _this._processor.process(metric);\n                });\n              });\n            })];\n          case 2:\n            _a.sent();\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  Meter.prototype.getProcessor = function () {\n    return this._processor;\n  };\n  Meter.prototype.shutdown = function () {\n    var _this = this;\n    if (this._isShutdown) {\n      return this._shuttingDownPromise;\n    }\n    this._isShutdown = true;\n    this._shuttingDownPromise = new Promise(function (resolve, reject) {\n      Promise.resolve().then(function () {\n        return _this._controller.shutdown();\n      }).then(resolve).catch(function (e) {\n        reject(e);\n      });\n    });\n    return this._shuttingDownPromise;\n  };\n  /**\n   * Registers metric to register.\n   * @param name The name of the metric.\n   * @param metric The metric to register.\n   */\n  Meter.prototype._registerMetric = function (name, metric) {\n    if (this._metrics.has(name)) {\n      diag.error(\"A metric with the name \" + name + \" has already been registered.\");\n      return;\n    }\n    this._metrics.set(name, metric);\n  };\n  /**\n   * Ensure a metric name conforms to the following rules:\n   *\n   * 1. They are non-empty strings\n   *\n   * 2. The first character must be non-numeric, non-space, non-punctuation\n   *\n   * 3. Subsequent characters must be belong to the alphanumeric characters,\n   *    '_', '.', and '-'.\n   *\n   * Names are case insensitive\n   *\n   * @param name Name of metric to be created\n   */\n  Meter.prototype._isValidName = function (name) {\n    return Boolean(name.match(/^[a-z][a-z0-9_.-]*$/i));\n  };\n  return Meter;\n}();\nexport { Meter };","map":{"version":3,"names":["diag","api","Resource","BatchObserver","CounterMetric","PushController","NoopExporter","UngroupedProcessor","SumObserverMetric","DEFAULT_CONFIG","DEFAULT_METRIC_OPTIONS","UpDownCounterMetric","UpDownSumObserverMetric","ValueObserverMetric","ValueRecorderMetric","merge","require","Meter","instrumentationLibrary","config","_batchObservers","_metrics","Map","_isShutdown","_shuttingDownPromise","Promise","resolve","mergedConfig","_processor","_a","processor","_resource","resource","empty","_instrumentationLibrary","exporter","interval","_controller","prototype","createValueRecorder","name","options","_isValidName","warn","NOOP_VALUE_RECORDER_METRIC","opt","__assign","valueRecorder","_registerMetric","createCounter","NOOP_COUNTER_METRIC","counter","createUpDownCounter","upDownCounter","createValueObserver","callback","NOOP_VALUE_OBSERVER_METRIC","valueObserver","createSumObserver","NOOP_SUM_OBSERVER_METRIC","sumObserver","createUpDownSumObserver","NOOP_UP_DOWN_SUM_OBSERVER_METRIC","upDownSumObserver","createBatchObserver","batchObserver","push","collect","observations","map","observer","all","sent","metricsRecords","Array","from","values","metric","getMetricRecord","then","records","forEach","metrics","_this","process","getProcessor","shutdown","reject","catch","e","has","error","set","Boolean","match"],"sources":["C:\\Users\\Sartaj\\Desktop\\ObservaCart\\observacart\\frontend\\node_modules\\@opentelemetry\\sdk-metrics-base\\src\\Meter.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { diag } from '@opentelemetry/api';\nimport * as api from '@opentelemetry/api-metrics';\nimport { InstrumentationLibrary } from '@opentelemetry/core';\nimport { Resource } from '@opentelemetry/resources';\nimport { BatchObserver } from './BatchObserver';\nimport { BaseBoundInstrument } from './BoundInstrument';\nimport { CounterMetric } from './CounterMetric';\nimport { PushController } from './export/Controller';\nimport { NoopExporter } from './export/NoopExporter';\nimport { Processor, UngroupedProcessor } from './export/Processor';\nimport { Metric } from './Metric';\nimport { SumObserverMetric } from './SumObserverMetric';\nimport { DEFAULT_CONFIG, DEFAULT_METRIC_OPTIONS, MeterConfig } from './types';\nimport { UpDownCounterMetric } from './UpDownCounterMetric';\nimport { UpDownSumObserverMetric } from './UpDownSumObserverMetric';\nimport { ValueObserverMetric } from './ValueObserverMetric';\nimport { ValueRecorderMetric } from './ValueRecorderMetric';\n// eslint-disable-next-line @typescript-eslint/no-var-requires\nconst merge = require('lodash.merge');\n\n/**\n * Meter is an implementation of the {@link Meter} interface.\n */\nexport class Meter implements api.Meter {\n  private readonly _batchObservers: BatchObserver[] = [];\n  private readonly _metrics = new Map<string, Metric<BaseBoundInstrument>>();\n  private readonly _processor: Processor;\n  private readonly _resource: Resource;\n  private readonly _instrumentationLibrary: InstrumentationLibrary;\n  private readonly _controller: PushController;\n  private _isShutdown = false;\n  private _shuttingDownPromise: Promise<void> = Promise.resolve();\n\n  /**\n   * Constructs a new Meter instance.\n   */\n  constructor(\n    instrumentationLibrary: InstrumentationLibrary,\n    config: MeterConfig = {}\n  ) {\n    const mergedConfig = merge({}, DEFAULT_CONFIG, config);\n    this._processor = mergedConfig.processor ?? new UngroupedProcessor();\n    this._resource =\n      mergedConfig.resource || Resource.empty();\n    this._instrumentationLibrary = instrumentationLibrary;\n    // start the push controller\n    const exporter = mergedConfig.exporter || new NoopExporter();\n    const interval = mergedConfig.interval;\n    this._controller = new PushController(this, exporter, interval);\n  }\n\n  /**\n   * Creates and returns a new {@link ValueRecorder}.\n   * @param name the name of the metric.\n   * @param [options] the metric options.\n   */\n  createValueRecorder(\n    name: string,\n    options?: api.MetricOptions\n  ): api.ValueRecorder {\n    if (!this._isValidName(name)) {\n      diag.warn(\n        `Invalid metric name ${name}. Defaulting to noop metric implementation.`\n      );\n      return api.NOOP_VALUE_RECORDER_METRIC;\n    }\n    const opt: api.MetricOptions = {\n      ...DEFAULT_METRIC_OPTIONS,\n      ...options,\n    };\n\n    const valueRecorder = new ValueRecorderMetric(\n      name,\n      opt,\n      this._processor,\n      this._resource,\n      this._instrumentationLibrary\n    );\n    this._registerMetric(name, valueRecorder);\n    return valueRecorder;\n  }\n\n  /**\n   * Creates a new counter metric. Generally, this kind of metric when the\n   * value is a quantity, the sum is of primary interest, and the event count\n   * and value distribution are not of primary interest.\n   * @param name the name of the metric.\n   * @param [options] the metric options.\n   */\n  createCounter(name: string, options?: api.MetricOptions): api.Counter {\n    if (!this._isValidName(name)) {\n      diag.warn(\n        `Invalid metric name ${name}. Defaulting to noop metric implementation.`\n      );\n      return api.NOOP_COUNTER_METRIC;\n    }\n    const opt: api.MetricOptions = {\n      ...DEFAULT_METRIC_OPTIONS,\n      ...options,\n    };\n    const counter = new CounterMetric(\n      name,\n      opt,\n      this._processor,\n      this._resource,\n      this._instrumentationLibrary\n    );\n    this._registerMetric(name, counter);\n    return counter;\n  }\n\n  /**\n   * Creates a new `UpDownCounter` metric. UpDownCounter is a synchronous\n   * instrument and very similar to Counter except that Add(increment)\n   * supports negative increments. It is generally useful for capturing changes\n   * in an amount of resources used, or any quantity that rises and falls\n   * during a request.\n   *\n   * @param name the name of the metric.\n   * @param [options] the metric options.\n   */\n  createUpDownCounter(\n    name: string,\n    options?: api.MetricOptions\n  ): api.UpDownCounter {\n    if (!this._isValidName(name)) {\n      diag.warn(\n        `Invalid metric name ${name}. Defaulting to noop metric implementation.`\n      );\n      return api.NOOP_COUNTER_METRIC;\n    }\n    const opt: api.MetricOptions = {\n      ...DEFAULT_METRIC_OPTIONS,\n      ...options,\n    };\n    const upDownCounter = new UpDownCounterMetric(\n      name,\n      opt,\n      this._processor,\n      this._resource,\n      this._instrumentationLibrary\n    );\n    this._registerMetric(name, upDownCounter);\n    return upDownCounter;\n  }\n\n  /**\n   * Creates a new `ValueObserver` metric.\n   * @param name the name of the metric.\n   * @param [options] the metric options.\n   * @param [callback] the value observer callback\n   */\n  createValueObserver(\n    name: string,\n    options: api.MetricOptions = {},\n    callback?: (observerResult: api.ObserverResult) => unknown\n  ): api.ValueObserver {\n    if (!this._isValidName(name)) {\n      diag.warn(\n        `Invalid metric name ${name}. Defaulting to noop metric implementation.`\n      );\n      return api.NOOP_VALUE_OBSERVER_METRIC;\n    }\n    const opt: api.MetricOptions = {\n      ...DEFAULT_METRIC_OPTIONS,\n      ...options,\n    };\n    const valueObserver = new ValueObserverMetric(\n      name,\n      opt,\n      this._processor,\n      this._resource,\n      this._instrumentationLibrary,\n      callback\n    );\n    this._registerMetric(name, valueObserver);\n    return valueObserver;\n  }\n\n  createSumObserver(\n    name: string,\n    options: api.MetricOptions = {},\n    callback?: (observerResult: api.ObserverResult) => unknown\n  ): api.SumObserver {\n    if (!this._isValidName(name)) {\n      diag.warn(\n        `Invalid metric name ${name}. Defaulting to noop metric implementation.`\n      );\n      return api.NOOP_SUM_OBSERVER_METRIC;\n    }\n    const opt: api.MetricOptions = {\n      ...DEFAULT_METRIC_OPTIONS,\n      ...options,\n    };\n    const sumObserver = new SumObserverMetric(\n      name,\n      opt,\n      this._processor,\n      this._resource,\n      this._instrumentationLibrary,\n      callback\n    );\n    this._registerMetric(name, sumObserver);\n    return sumObserver;\n  }\n\n  /**\n   * Creates a new `UpDownSumObserver` metric.\n   * @param name the name of the metric.\n   * @param [options] the metric options.\n   * @param [callback] the value observer callback\n   */\n  createUpDownSumObserver(\n    name: string,\n    options: api.MetricOptions = {},\n    callback?: (observerResult: api.ObserverResult) => unknown\n  ): api.UpDownSumObserver {\n    if (!this._isValidName(name)) {\n      diag.warn(\n        `Invalid metric name ${name}. Defaulting to noop metric implementation.`\n      );\n      return api.NOOP_UP_DOWN_SUM_OBSERVER_METRIC;\n    }\n    const opt: api.MetricOptions = {\n      ...DEFAULT_METRIC_OPTIONS,\n      ...options,\n    };\n    const upDownSumObserver = new UpDownSumObserverMetric(\n      name,\n      opt,\n      this._processor,\n      this._resource,\n      this._instrumentationLibrary,\n      callback\n    );\n    this._registerMetric(name, upDownSumObserver);\n    return upDownSumObserver;\n  }\n\n  /**\n   * Creates a new batch observer.\n   * @param callback the batch observer callback\n   * @param [options] the batch options.\n   */\n  createBatchObserver(\n    callback: (observerResult: api.BatchObserverResult) => void,\n    options: api.BatchObserverOptions = {}\n  ): BatchObserver {\n    const opt: api.BatchObserverOptions = {\n      ...options,\n    };\n    const batchObserver = new BatchObserver(opt, callback);\n    this._batchObservers.push(batchObserver);\n    return batchObserver;\n  }\n\n  /**\n   * Collects all the metrics created with this `Meter` for export.\n   *\n   * Utilizes the processor to create checkpoints of the current values in\n   * each aggregator belonging to the metrics that were created with this\n   * meter instance.\n   */\n  async collect(): Promise<void> {\n    // call batch observers first\n    const observations = this._batchObservers.map(observer => {\n      return observer.collect();\n    });\n    await Promise.all(observations);\n\n    // after this all remaining metrics can be run\n    const metricsRecords = Array.from(this._metrics.values()).map(metric => {\n      return metric.getMetricRecord();\n    });\n\n    await Promise.all(metricsRecords).then(records => {\n      records.forEach(metrics => {\n        metrics.forEach(metric => this._processor.process(metric));\n      });\n    });\n  }\n\n  getProcessor(): Processor {\n    return this._processor;\n  }\n\n  shutdown(): Promise<void> {\n    if (this._isShutdown) {\n      return this._shuttingDownPromise;\n    }\n    this._isShutdown = true;\n\n    this._shuttingDownPromise = new Promise((resolve, reject) => {\n      Promise.resolve()\n        .then(() => {\n          return this._controller.shutdown();\n        })\n        .then(resolve)\n        .catch(e => {\n          reject(e);\n        });\n    });\n    return this._shuttingDownPromise;\n  }\n\n  /**\n   * Registers metric to register.\n   * @param name The name of the metric.\n   * @param metric The metric to register.\n   */\n  private _registerMetric<T extends BaseBoundInstrument>(\n    name: string,\n    metric: Metric<T>\n  ): void {\n    if (this._metrics.has(name)) {\n      diag.error(`A metric with the name ${name} has already been registered.`);\n      return;\n    }\n    this._metrics.set(name, metric);\n  }\n\n  /**\n   * Ensure a metric name conforms to the following rules:\n   *\n   * 1. They are non-empty strings\n   *\n   * 2. The first character must be non-numeric, non-space, non-punctuation\n   *\n   * 3. Subsequent characters must be belong to the alphanumeric characters,\n   *    '_', '.', and '-'.\n   *\n   * Names are case insensitive\n   *\n   * @param name Name of metric to be created\n   */\n  private _isValidName(name: string): boolean {\n    return Boolean(name.match(/^[a-z][a-z0-9_.-]*$/i));\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}