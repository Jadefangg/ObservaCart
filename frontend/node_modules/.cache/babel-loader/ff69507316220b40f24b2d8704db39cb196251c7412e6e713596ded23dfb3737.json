{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as api from '@opentelemetry/api-metrics';\nimport { hashLabels } from './Utils';\n/** This is a SDK implementation of {@link Metric} interface. */\nvar Metric = /** @class */function () {\n  function Metric(_name, _options, _kind, resource, instrumentationLibrary) {\n    this._name = _name;\n    this._options = _options;\n    this._kind = _kind;\n    this.resource = resource;\n    this.instrumentationLibrary = instrumentationLibrary;\n    this._instruments = new Map();\n    this._disabled = !!_options.disabled;\n    this._valueType = typeof _options.valueType === 'number' ? _options.valueType : api.ValueType.DOUBLE;\n    this._boundaries = _options.boundaries;\n    this._descriptor = this._getMetricDescriptor();\n    this._aggregationTemporality = _options.aggregationTemporality === undefined ? api.AggregationTemporality.AGGREGATION_TEMPORALITY_CUMULATIVE : _options.aggregationTemporality;\n  }\n  /**\n   * Returns an Instrument associated with specified Labels.\n   * It is recommended to keep a reference to the Instrument instead of always\n   * calling this method for each operation.\n   * @param labels key-values pairs that are associated with a specific metric\n   *     that you want to record.\n   */\n  Metric.prototype.bind = function (labels) {\n    var hash = hashLabels(labels);\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    if (this._instruments.has(hash)) return this._instruments.get(hash);\n    var instrument = this._makeInstrument(labels);\n    this._instruments.set(hash, instrument);\n    return instrument;\n  };\n  /**\n   * Removes the Instrument from the metric, if it is present.\n   * @param labels key-values pairs that are associated with a specific metric.\n   */\n  Metric.prototype.unbind = function (labels) {\n    this._instruments.delete(hashLabels(labels));\n  };\n  /**\n   * Clears all Instruments from the Metric.\n   */\n  Metric.prototype.clear = function () {\n    this._instruments.clear();\n  };\n  /**\n   * Returns kind of metric\n   */\n  Metric.prototype.getKind = function () {\n    return this._kind;\n  };\n  Metric.prototype.getAggregationTemporality = function () {\n    return this._aggregationTemporality;\n  };\n  Metric.prototype.getMetricRecord = function () {\n    var _this = this;\n    return new Promise(function (resolve) {\n      resolve(Array.from(_this._instruments.values()).map(function (instrument) {\n        return {\n          descriptor: _this._descriptor,\n          labels: instrument.getLabels(),\n          aggregator: instrument.getAggregator(),\n          aggregationTemporality: _this.getAggregationTemporality(),\n          resource: _this.resource,\n          instrumentationLibrary: _this.instrumentationLibrary\n        };\n      }));\n    });\n  };\n  Metric.prototype._getMetricDescriptor = function () {\n    return __assign({\n      name: this._name,\n      description: this._options.description || '',\n      unit: this._options.unit || '1',\n      metricKind: this._kind,\n      valueType: this._valueType\n    }, this._boundaries && {\n      boundaries: this._boundaries\n    });\n  };\n  return Metric;\n}();\nexport { Metric };","map":{"version":3,"names":["api","hashLabels","Metric","_name","_options","_kind","resource","instrumentationLibrary","_instruments","Map","_disabled","disabled","_valueType","valueType","ValueType","DOUBLE","_boundaries","boundaries","_descriptor","_getMetricDescriptor","_aggregationTemporality","aggregationTemporality","undefined","AggregationTemporality","AGGREGATION_TEMPORALITY_CUMULATIVE","prototype","bind","labels","hash","has","get","instrument","_makeInstrument","set","unbind","delete","clear","getKind","getAggregationTemporality","getMetricRecord","_this","Promise","resolve","Array","from","values","map","descriptor","getLabels","aggregator","getAggregator","__assign","name","description","unit","metricKind"],"sources":["C:\\Users\\Sartaj\\Desktop\\ObservaCart\\observacart\\frontend\\node_modules\\@opentelemetry\\sdk-metrics-base\\src\\Metric.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as api from '@opentelemetry/api-metrics';\nimport { InstrumentationLibrary } from '@opentelemetry/core';\nimport { Resource } from '@opentelemetry/resources';\nimport { BaseBoundInstrument } from './BoundInstrument';\nimport { MetricDescriptor, MetricKind, MetricRecord } from './export/types';\nimport { hashLabels } from './Utils';\n\n/** This is a SDK implementation of {@link Metric} interface. */\nexport abstract class Metric<T extends BaseBoundInstrument>\n  implements api.UnboundMetric<T> {\n  protected readonly _disabled: boolean;\n  protected readonly _valueType: api.ValueType;\n  protected readonly _descriptor: MetricDescriptor;\n  protected readonly _boundaries: number[] | undefined;\n  protected readonly _aggregationTemporality: api.AggregationTemporality;\n  private readonly _instruments: Map<string, T> = new Map();\n\n  constructor(\n    private readonly _name: string,\n    private readonly _options: api.MetricOptions,\n    private readonly _kind: MetricKind,\n    readonly resource: Resource,\n    readonly instrumentationLibrary: InstrumentationLibrary\n  ) {\n    this._disabled = !!_options.disabled;\n    this._valueType =\n      typeof _options.valueType === 'number'\n        ? _options.valueType\n        : api.ValueType.DOUBLE;\n    this._boundaries = _options.boundaries;\n    this._descriptor = this._getMetricDescriptor();\n    this._aggregationTemporality =\n      _options.aggregationTemporality === undefined\n        ? api.AggregationTemporality.AGGREGATION_TEMPORALITY_CUMULATIVE\n        : _options.aggregationTemporality;\n  }\n\n  /**\n   * Returns an Instrument associated with specified Labels.\n   * It is recommended to keep a reference to the Instrument instead of always\n   * calling this method for each operation.\n   * @param labels key-values pairs that are associated with a specific metric\n   *     that you want to record.\n   */\n  bind(labels: api.Labels): T {\n    const hash = hashLabels(labels);\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    if (this._instruments.has(hash)) return this._instruments.get(hash)!;\n\n    const instrument = this._makeInstrument(labels);\n    this._instruments.set(hash, instrument);\n    return instrument;\n  }\n\n  /**\n   * Removes the Instrument from the metric, if it is present.\n   * @param labels key-values pairs that are associated with a specific metric.\n   */\n  unbind(labels: api.Labels): void {\n    this._instruments.delete(hashLabels(labels));\n  }\n\n  /**\n   * Clears all Instruments from the Metric.\n   */\n  clear(): void {\n    this._instruments.clear();\n  }\n\n  /**\n   * Returns kind of metric\n   */\n  getKind(): MetricKind {\n    return this._kind;\n  }\n\n  getAggregationTemporality(): api.AggregationTemporality {\n    return this._aggregationTemporality;\n  }\n\n  getMetricRecord(): Promise<MetricRecord[]> {\n    return new Promise(resolve => {\n      resolve(\n        Array.from(this._instruments.values()).map(instrument => ({\n          descriptor: this._descriptor,\n          labels: instrument.getLabels(),\n          aggregator: instrument.getAggregator(),\n          aggregationTemporality: this.getAggregationTemporality(),\n          resource: this.resource,\n          instrumentationLibrary: this.instrumentationLibrary,\n        }))\n      );\n    });\n  }\n\n  private _getMetricDescriptor(): MetricDescriptor {\n    return {\n      name: this._name,\n      description: this._options.description || '',\n      unit: this._options.unit || '1',\n      metricKind: this._kind,\n      valueType: this._valueType,\n      ...(this._boundaries && { boundaries: this._boundaries }),\n    };\n  }\n\n  protected abstract _makeInstrument(labels: api.Labels): T;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}