{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { merge } from '@opentelemetry/core';\nimport { defaultResource } from '@opentelemetry/resources';\nimport { Tracer } from './Tracer';\nimport { loadDefaultConfig } from './config';\nimport { MultiSpanProcessor } from './MultiSpanProcessor';\nimport { reconfigureLimits } from './utility';\nexport var ForceFlushState;\n(function (ForceFlushState) {\n  ForceFlushState[ForceFlushState[\"resolved\"] = 0] = \"resolved\";\n  ForceFlushState[ForceFlushState[\"timeout\"] = 1] = \"timeout\";\n  ForceFlushState[ForceFlushState[\"error\"] = 2] = \"error\";\n  ForceFlushState[ForceFlushState[\"unresolved\"] = 3] = \"unresolved\";\n})(ForceFlushState || (ForceFlushState = {}));\n/**\n * This class represents a basic tracer provider which platform libraries can extend\n */\nexport class BasicTracerProvider {\n  _config;\n  _tracers = new Map();\n  _resource;\n  _activeSpanProcessor;\n  constructor(config = {}) {\n    const mergedConfig = merge({}, loadDefaultConfig(), reconfigureLimits(config));\n    this._resource = mergedConfig.resource ?? defaultResource();\n    this._config = Object.assign({}, mergedConfig, {\n      resource: this._resource\n    });\n    const spanProcessors = [];\n    if (config.spanProcessors?.length) {\n      spanProcessors.push(...config.spanProcessors);\n    }\n    this._activeSpanProcessor = new MultiSpanProcessor(spanProcessors);\n  }\n  getTracer(name, version, options) {\n    const key = `${name}@${version || ''}:${options?.schemaUrl || ''}`;\n    if (!this._tracers.has(key)) {\n      this._tracers.set(key, new Tracer({\n        name,\n        version,\n        schemaUrl: options?.schemaUrl\n      }, this._config, this._resource, this._activeSpanProcessor));\n    }\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return this._tracers.get(key);\n  }\n  forceFlush() {\n    const timeout = this._config.forceFlushTimeoutMillis;\n    const promises = this._activeSpanProcessor['_spanProcessors'].map(spanProcessor => {\n      return new Promise(resolve => {\n        let state;\n        const timeoutInterval = setTimeout(() => {\n          resolve(new Error(`Span processor did not completed within timeout period of ${timeout} ms`));\n          state = ForceFlushState.timeout;\n        }, timeout);\n        spanProcessor.forceFlush().then(() => {\n          clearTimeout(timeoutInterval);\n          if (state !== ForceFlushState.timeout) {\n            state = ForceFlushState.resolved;\n            resolve(state);\n          }\n        }).catch(error => {\n          clearTimeout(timeoutInterval);\n          state = ForceFlushState.error;\n          resolve(error);\n        });\n      });\n    });\n    return new Promise((resolve, reject) => {\n      Promise.all(promises).then(results => {\n        const errors = results.filter(result => result !== ForceFlushState.resolved);\n        if (errors.length > 0) {\n          reject(errors);\n        } else {\n          resolve();\n        }\n      }).catch(error => reject([error]));\n    });\n  }\n  shutdown() {\n    return this._activeSpanProcessor.shutdown();\n  }\n}","map":{"version":3,"names":["merge","defaultResource","Tracer","loadDefaultConfig","MultiSpanProcessor","reconfigureLimits","ForceFlushState","BasicTracerProvider","_config","_tracers","Map","_resource","_activeSpanProcessor","constructor","config","mergedConfig","resource","Object","assign","spanProcessors","length","push","getTracer","name","version","options","key","schemaUrl","has","set","get","forceFlush","timeout","forceFlushTimeoutMillis","promises","map","spanProcessor","Promise","resolve","state","timeoutInterval","setTimeout","Error","then","clearTimeout","resolved","catch","error","reject","all","results","errors","filter","result","shutdown"],"sources":["C:/Users/Sartaj/Desktop/ObservaCart/observacart/frontend/node_modules/@opentelemetry/sdk-trace-base/build/esm/BasicTracerProvider.js"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { merge } from '@opentelemetry/core';\nimport { defaultResource } from '@opentelemetry/resources';\nimport { Tracer } from './Tracer';\nimport { loadDefaultConfig } from './config';\nimport { MultiSpanProcessor } from './MultiSpanProcessor';\nimport { reconfigureLimits } from './utility';\nexport var ForceFlushState;\n(function (ForceFlushState) {\n    ForceFlushState[ForceFlushState[\"resolved\"] = 0] = \"resolved\";\n    ForceFlushState[ForceFlushState[\"timeout\"] = 1] = \"timeout\";\n    ForceFlushState[ForceFlushState[\"error\"] = 2] = \"error\";\n    ForceFlushState[ForceFlushState[\"unresolved\"] = 3] = \"unresolved\";\n})(ForceFlushState || (ForceFlushState = {}));\n/**\n * This class represents a basic tracer provider which platform libraries can extend\n */\nexport class BasicTracerProvider {\n    _config;\n    _tracers = new Map();\n    _resource;\n    _activeSpanProcessor;\n    constructor(config = {}) {\n        const mergedConfig = merge({}, loadDefaultConfig(), reconfigureLimits(config));\n        this._resource = mergedConfig.resource ?? defaultResource();\n        this._config = Object.assign({}, mergedConfig, {\n            resource: this._resource,\n        });\n        const spanProcessors = [];\n        if (config.spanProcessors?.length) {\n            spanProcessors.push(...config.spanProcessors);\n        }\n        this._activeSpanProcessor = new MultiSpanProcessor(spanProcessors);\n    }\n    getTracer(name, version, options) {\n        const key = `${name}@${version || ''}:${options?.schemaUrl || ''}`;\n        if (!this._tracers.has(key)) {\n            this._tracers.set(key, new Tracer({ name, version, schemaUrl: options?.schemaUrl }, this._config, this._resource, this._activeSpanProcessor));\n        }\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return this._tracers.get(key);\n    }\n    forceFlush() {\n        const timeout = this._config.forceFlushTimeoutMillis;\n        const promises = this._activeSpanProcessor['_spanProcessors'].map((spanProcessor) => {\n            return new Promise(resolve => {\n                let state;\n                const timeoutInterval = setTimeout(() => {\n                    resolve(new Error(`Span processor did not completed within timeout period of ${timeout} ms`));\n                    state = ForceFlushState.timeout;\n                }, timeout);\n                spanProcessor\n                    .forceFlush()\n                    .then(() => {\n                    clearTimeout(timeoutInterval);\n                    if (state !== ForceFlushState.timeout) {\n                        state = ForceFlushState.resolved;\n                        resolve(state);\n                    }\n                })\n                    .catch(error => {\n                    clearTimeout(timeoutInterval);\n                    state = ForceFlushState.error;\n                    resolve(error);\n                });\n            });\n        });\n        return new Promise((resolve, reject) => {\n            Promise.all(promises)\n                .then(results => {\n                const errors = results.filter(result => result !== ForceFlushState.resolved);\n                if (errors.length > 0) {\n                    reject(errors);\n                }\n                else {\n                    resolve();\n                }\n            })\n                .catch(error => reject([error]));\n        });\n    }\n    shutdown() {\n        return this._activeSpanProcessor.shutdown();\n    }\n}\n//# sourceMappingURL=BasicTracerProvider.js.map"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,KAAK,QAAQ,qBAAqB;AAC3C,SAASC,eAAe,QAAQ,0BAA0B;AAC1D,SAASC,MAAM,QAAQ,UAAU;AACjC,SAASC,iBAAiB,QAAQ,UAAU;AAC5C,SAASC,kBAAkB,QAAQ,sBAAsB;AACzD,SAASC,iBAAiB,QAAQ,WAAW;AAC7C,OAAO,IAAIC,eAAe;AAC1B,CAAC,UAAUA,eAAe,EAAE;EACxBA,eAAe,CAACA,eAAe,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,GAAG,UAAU;EAC7DA,eAAe,CAACA,eAAe,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,GAAG,SAAS;EAC3DA,eAAe,CAACA,eAAe,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,GAAG,OAAO;EACvDA,eAAe,CAACA,eAAe,CAAC,YAAY,CAAC,GAAG,CAAC,CAAC,GAAG,YAAY;AACrE,CAAC,EAAEA,eAAe,KAAKA,eAAe,GAAG,CAAC,CAAC,CAAC,CAAC;AAC7C;AACA;AACA;AACA,OAAO,MAAMC,mBAAmB,CAAC;EAC7BC,OAAO;EACPC,QAAQ,GAAG,IAAIC,GAAG,CAAC,CAAC;EACpBC,SAAS;EACTC,oBAAoB;EACpBC,WAAWA,CAACC,MAAM,GAAG,CAAC,CAAC,EAAE;IACrB,MAAMC,YAAY,GAAGf,KAAK,CAAC,CAAC,CAAC,EAAEG,iBAAiB,CAAC,CAAC,EAAEE,iBAAiB,CAACS,MAAM,CAAC,CAAC;IAC9E,IAAI,CAACH,SAAS,GAAGI,YAAY,CAACC,QAAQ,IAAIf,eAAe,CAAC,CAAC;IAC3D,IAAI,CAACO,OAAO,GAAGS,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAEH,YAAY,EAAE;MAC3CC,QAAQ,EAAE,IAAI,CAACL;IACnB,CAAC,CAAC;IACF,MAAMQ,cAAc,GAAG,EAAE;IACzB,IAAIL,MAAM,CAACK,cAAc,EAAEC,MAAM,EAAE;MAC/BD,cAAc,CAACE,IAAI,CAAC,GAAGP,MAAM,CAACK,cAAc,CAAC;IACjD;IACA,IAAI,CAACP,oBAAoB,GAAG,IAAIR,kBAAkB,CAACe,cAAc,CAAC;EACtE;EACAG,SAASA,CAACC,IAAI,EAAEC,OAAO,EAAEC,OAAO,EAAE;IAC9B,MAAMC,GAAG,GAAG,GAAGH,IAAI,IAAIC,OAAO,IAAI,EAAE,IAAIC,OAAO,EAAEE,SAAS,IAAI,EAAE,EAAE;IAClE,IAAI,CAAC,IAAI,CAAClB,QAAQ,CAACmB,GAAG,CAACF,GAAG,CAAC,EAAE;MACzB,IAAI,CAACjB,QAAQ,CAACoB,GAAG,CAACH,GAAG,EAAE,IAAIxB,MAAM,CAAC;QAAEqB,IAAI;QAAEC,OAAO;QAAEG,SAAS,EAAEF,OAAO,EAAEE;MAAU,CAAC,EAAE,IAAI,CAACnB,OAAO,EAAE,IAAI,CAACG,SAAS,EAAE,IAAI,CAACC,oBAAoB,CAAC,CAAC;IACjJ;IACA;IACA,OAAO,IAAI,CAACH,QAAQ,CAACqB,GAAG,CAACJ,GAAG,CAAC;EACjC;EACAK,UAAUA,CAAA,EAAG;IACT,MAAMC,OAAO,GAAG,IAAI,CAACxB,OAAO,CAACyB,uBAAuB;IACpD,MAAMC,QAAQ,GAAG,IAAI,CAACtB,oBAAoB,CAAC,iBAAiB,CAAC,CAACuB,GAAG,CAAEC,aAAa,IAAK;MACjF,OAAO,IAAIC,OAAO,CAACC,OAAO,IAAI;QAC1B,IAAIC,KAAK;QACT,MAAMC,eAAe,GAAGC,UAAU,CAAC,MAAM;UACrCH,OAAO,CAAC,IAAII,KAAK,CAAC,6DAA6DV,OAAO,KAAK,CAAC,CAAC;UAC7FO,KAAK,GAAGjC,eAAe,CAAC0B,OAAO;QACnC,CAAC,EAAEA,OAAO,CAAC;QACXI,aAAa,CACRL,UAAU,CAAC,CAAC,CACZY,IAAI,CAAC,MAAM;UACZC,YAAY,CAACJ,eAAe,CAAC;UAC7B,IAAID,KAAK,KAAKjC,eAAe,CAAC0B,OAAO,EAAE;YACnCO,KAAK,GAAGjC,eAAe,CAACuC,QAAQ;YAChCP,OAAO,CAACC,KAAK,CAAC;UAClB;QACJ,CAAC,CAAC,CACGO,KAAK,CAACC,KAAK,IAAI;UAChBH,YAAY,CAACJ,eAAe,CAAC;UAC7BD,KAAK,GAAGjC,eAAe,CAACyC,KAAK;UAC7BT,OAAO,CAACS,KAAK,CAAC;QAClB,CAAC,CAAC;MACN,CAAC,CAAC;IACN,CAAC,CAAC;IACF,OAAO,IAAIV,OAAO,CAAC,CAACC,OAAO,EAAEU,MAAM,KAAK;MACpCX,OAAO,CAACY,GAAG,CAACf,QAAQ,CAAC,CAChBS,IAAI,CAACO,OAAO,IAAI;QACjB,MAAMC,MAAM,GAAGD,OAAO,CAACE,MAAM,CAACC,MAAM,IAAIA,MAAM,KAAK/C,eAAe,CAACuC,QAAQ,CAAC;QAC5E,IAAIM,MAAM,CAAC/B,MAAM,GAAG,CAAC,EAAE;UACnB4B,MAAM,CAACG,MAAM,CAAC;QAClB,CAAC,MACI;UACDb,OAAO,CAAC,CAAC;QACb;MACJ,CAAC,CAAC,CACGQ,KAAK,CAACC,KAAK,IAAIC,MAAM,CAAC,CAACD,KAAK,CAAC,CAAC,CAAC;IACxC,CAAC,CAAC;EACN;EACAO,QAAQA,CAAA,EAAG;IACP,OAAO,IAAI,CAAC1C,oBAAoB,CAAC0C,QAAQ,CAAC,CAAC;EAC/C;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}